// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: build/bazel/remote/execution/v2/remote_execution.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Bazel Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An `Action` captures all the information about an execution which is required
/// to reproduce it.
///
/// `Action`s are the core component of the [Execution] service. A single
/// `Action` represents a repeatable action that can be performed by the
/// execution service. `Action`s can be succinctly identified by the digest of
/// their wire format encoding and, once an `Action` has been executed, will be
/// cached in the action cache. Future requests can then use the cached result
/// rather than needing to run afresh.
///
/// When a server completes execution of an
/// [Action][build.bazel.remote.execution.v2.Action], it MAY choose to
/// cache the [result][build.bazel.remote.execution.v2.ActionResult] in
/// the [ActionCache][build.bazel.remote.execution.v2.ActionCache] unless
/// `do_not_cache` is `true`. Clients SHOULD expect the server to do so. By
/// default, future calls to
/// [Execute][build.bazel.remote.execution.v2.Execution.Execute] the same
/// `Action` will also serve their results from the cache. Clients must take care
/// to understand the caching behaviour. Ideally, all `Action`s will be
/// reproducible so that serving a result from cache is always desirable and
/// correct.
public struct Build_Bazel_Remote_Execution_V2_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The digest of the [Command][build.bazel.remote.execution.v2.Command]
  /// to run, which MUST be present in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  public var commandDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _commandDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_commandDigest = newValue}
  }
  /// Returns true if `commandDigest` has been explicitly set.
  public var hasCommandDigest: Bool {return self._commandDigest != nil}
  /// Clears the value of `commandDigest`. Subsequent reads from it will return its default value.
  public mutating func clearCommandDigest() {self._commandDigest = nil}

  /// The digest of the root
  /// [Directory][build.bazel.remote.execution.v2.Directory] for the input
  /// files. The files in the directory tree are available in the correct
  /// location on the build machine before the command is executed. The root
  /// directory, as well as every subdirectory and content blob referred to, MUST
  /// be in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  public var inputRootDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _inputRootDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_inputRootDigest = newValue}
  }
  /// Returns true if `inputRootDigest` has been explicitly set.
  public var hasInputRootDigest: Bool {return self._inputRootDigest != nil}
  /// Clears the value of `inputRootDigest`. Subsequent reads from it will return its default value.
  public mutating func clearInputRootDigest() {self._inputRootDigest = nil}

  /// A timeout after which the execution should be killed. If the timeout is
  /// absent, then the client is specifying that the execution should continue
  /// as long as the server will let it. The server SHOULD impose a timeout if
  /// the client does not specify one, however, if the client does specify a
  /// timeout that is longer than the server's maximum timeout, the server MUST
  /// reject the request.
  ///
  /// The timeout is a part of the
  /// [Action][build.bazel.remote.execution.v2.Action] message, and
  /// therefore two `Actions` with different timeouts are different, even if they
  /// are otherwise identical. This is because, if they were not, running an
  /// `Action` with a lower timeout than is required might result in a cache hit
  /// from an execution run with a longer timeout, hiding the fact that the
  /// timeout is too short. By encoding it directly in the `Action`, a lower
  /// timeout will result in a cache miss and the execution timeout will fail
  /// immediately, rather than whenever the cache entry gets evicted.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// If true, then the `Action`'s result cannot be cached, and in-flight
  /// requests for the same `Action` may not be merged.
  public var doNotCache: Bool = false

  /// An optional additional salt value used to place this `Action` into a
  /// separate cache namespace from other instances having the same field
  /// contents. This salt typically comes from operational configuration
  /// specific to sources such as repo and service configuration,
  /// and allows disowning an entire set of ActionResults that might have been
  /// poisoned by buggy software or tool failures.
  public var salt: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commandDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _inputRootDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A `Command` is the actual command executed by a worker running an
/// [Action][build.bazel.remote.execution.v2.Action] and specifications of its
/// environment.
///
/// Except as otherwise required, the environment (such as which system
/// libraries or binaries are available, and what filesystems are mounted where)
/// is defined by and specific to the implementation of the remote execution API.
public struct Build_Bazel_Remote_Execution_V2_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The arguments to the command. The first argument must be the path to the
  /// executable, which must be either a relative path, in which case it is
  /// evaluated with respect to the input root, or an absolute path.
  public var arguments: [String] = []

  /// The environment variables to set when running the program. The worker may
  /// provide its own default environment variables; these defaults can be
  /// overridden using this field. Additional variables can also be specified.
  ///
  /// In order to ensure that equivalent
  /// [Command][build.bazel.remote.execution.v2.Command]s always hash to the same
  /// value, the environment variables MUST be lexicographically sorted by name.
  /// Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
  public var environmentVariables: [Build_Bazel_Remote_Execution_V2_Command.EnvironmentVariable] = []

  /// A list of the output files that the client expects to retrieve from the
  /// action. Only the listed files, as well as directories listed in
  /// `output_directories`, will be returned to the client as output.
  /// Other files or directories that may be created during command execution
  /// are discarded.
  ///
  /// The paths are relative to the working directory of the action execution.
  /// The paths are specified using a single forward slash (`/`) as a path
  /// separator, even if the execution platform natively uses a different
  /// separator. The path MUST NOT include a trailing slash, nor a leading slash,
  /// being a relative path.
  ///
  /// In order to ensure consistent hashing of the same Action, the output paths
  /// MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
  /// bytes).
  ///
  /// An output file cannot be duplicated, be a parent of another output file, or
  /// have the same path as any of the listed output directories.
  ///
  /// Directories leading up to the output files are created by the worker prior
  /// to execution, even if they are not explicitly part of the input root.
  ///
  /// DEPRECATED since v2.1: Use `output_paths` instead.
  public var outputFiles: [String] = []

  /// A list of the output directories that the client expects to retrieve from
  /// the action. Only the listed directories will be returned (an entire
  /// directory structure will be returned as a
  /// [Tree][build.bazel.remote.execution.v2.Tree] message digest, see
  /// [OutputDirectory][build.bazel.remote.execution.v2.OutputDirectory]), as
  /// well as files listed in `output_files`. Other files or directories that
  /// may be created during command execution are discarded.
  ///
  /// The paths are relative to the working directory of the action execution.
  /// The paths are specified using a single forward slash (`/`) as a path
  /// separator, even if the execution platform natively uses a different
  /// separator. The path MUST NOT include a trailing slash, nor a leading slash,
  /// being a relative path. The special value of empty string is allowed,
  /// although not recommended, and can be used to capture the entire working
  /// directory tree, including inputs.
  ///
  /// In order to ensure consistent hashing of the same Action, the output paths
  /// MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
  /// bytes).
  ///
  /// An output directory cannot be duplicated or have the same path as any of
  /// the listed output files. An output directory is allowed to be a parent of
  /// another output directory.
  ///
  /// Directories leading up to the output directories (but not the output
  /// directories themselves) are created by the worker prior to execution, even
  /// if they are not explicitly part of the input root.
  ///
  /// DEPRECATED since 2.1: Use `output_paths` instead.
  public var outputDirectories: [String] = []

  /// A list of the output paths that the client expects to retrieve from the
  /// action. Only the listed paths will be returned to the client as output.
  /// The type of the output (file or directory) is not specified, and will be
  /// determined by the server after action execution. If the resulting path is
  /// a file, it will be returned in an
  /// [OutputFile][build.bazel.remote.execution.v2.OutputFile]) typed field.
  /// If the path is a directory, the entire directory structure will be returned
  /// as a [Tree][build.bazel.remote.execution.v2.Tree] message digest, see
  /// [OutputDirectory][build.bazel.remote.execution.v2.OutputDirectory])
  /// Other files or directories that may be created during command execution
  /// are discarded.
  ///
  /// The paths are relative to the working directory of the action execution.
  /// The paths are specified using a single forward slash (`/`) as a path
  /// separator, even if the execution platform natively uses a different
  /// separator. The path MUST NOT include a trailing slash, nor a leading slash,
  /// being a relative path.
  ///
  /// In order to ensure consistent hashing of the same Action, the output paths
  /// MUST be deduplicated and sorted lexicographically by code point (or,
  /// equivalently, by UTF-8 bytes).
  ///
  /// Directories leading up to the output paths are created by the worker prior
  /// to execution, even if they are not explicitly part of the input root.
  ///
  /// New in v2.1: this field supersedes the DEPRECATED `output_files` and
  /// `output_directories` fields. If `output_paths` is used, `output_files` and
  /// `output_directories` will be ignored!
  public var outputPaths: [String] = []

  /// The platform requirements for the execution environment. The server MAY
  /// choose to execute the action on any worker satisfying the requirements, so
  /// the client SHOULD ensure that running the action on any such worker will
  /// have the same result.
  /// A detailed lexicon for this can be found in the accompanying platform.md.
  public var platform: Build_Bazel_Remote_Execution_V2_Platform {
    get {return _platform ?? Build_Bazel_Remote_Execution_V2_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  /// The working directory, relative to the input root, for the command to run
  /// in. It must be a directory which exists in the input tree. If it is left
  /// empty, then the action is run in the input root.
  public var workingDirectory: String = String()

  /// A list of keys for node properties the client expects to retrieve for
  /// output files and directories. Keys are either names of string-based
  /// [NodeProperty][build.bazel.remote.execution.v2.NodeProperty] or
  /// names of fields in [NodeProperties][build.bazel.remote.execution.v2.NodeProperties].
  /// In order to ensure that equivalent `Action`s always hash to the same
  /// value, the node properties MUST be lexicographically sorted by name.
  /// Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
  ///
  /// The interpretation of string-based properties is server-dependent. If a
  /// property is not recognized by the server, the server will return an
  /// `INVALID_ARGUMENT`.
  public var outputNodeProperties: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An `EnvironmentVariable` is one variable to set in the running program's
  /// environment.
  public struct EnvironmentVariable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The variable name.
    public var name: String = String()

    /// The variable value.
    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _platform: Build_Bazel_Remote_Execution_V2_Platform? = nil
}

/// A `Platform` is a set of requirements, such as hardware, operating system, or
/// compiler toolchain, for an
/// [Action][build.bazel.remote.execution.v2.Action]'s execution
/// environment. A `Platform` is represented as a series of key-value pairs
/// representing the properties that are required of the platform.
public struct Build_Bazel_Remote_Execution_V2_Platform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The properties that make up this platform. In order to ensure that
  /// equivalent `Platform`s always hash to the same value, the properties MUST
  /// be lexicographically sorted by name, and then by value. Sorting of strings
  /// is done by code point, equivalently, by the UTF-8 bytes.
  public var properties: [Build_Bazel_Remote_Execution_V2_Platform.Property] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single property for the environment. The server is responsible for
  /// specifying the property `name`s that it accepts. If an unknown `name` is
  /// provided in the requirements for an
  /// [Action][build.bazel.remote.execution.v2.Action], the server SHOULD
  /// reject the execution request. If permitted by the server, the same `name`
  /// may occur multiple times.
  ///
  /// The server is also responsible for specifying the interpretation of
  /// property `value`s. For instance, a property describing how much RAM must be
  /// available may be interpreted as allowing a worker with 16GB to fulfill a
  /// request for 8GB, while a property describing the OS environment on which
  /// the action must be performed may require an exact match with the worker's
  /// OS.
  ///
  /// The server MAY use the `value` of one or more properties to determine how
  /// it sets up the execution environment, such as by making specific system
  /// files available to the worker.
  ///
  /// Both names and values are typically case-sensitive. Note that the platform
  /// is implicitly part of the action digest, so even tiny changes in the names
  /// or values (like changing case) may result in different action cache
  /// entries.
  public struct Property {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The property name.
    public var name: String = String()

    /// The property value.
    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A `Directory` represents a directory node in a file tree, containing zero or
/// more children [FileNodes][build.bazel.remote.execution.v2.FileNode],
/// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode] and
/// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode].
/// Each `Node` contains its name in the directory, either the digest of its
/// content (either a file blob or a `Directory` proto) or a symlink target, as
/// well as possibly some metadata about the file or directory.
///
/// In order to ensure that two equivalent directory trees hash to the same
/// value, the following restrictions MUST be obeyed when constructing a
/// a `Directory`:
///
/// * Every child in the directory must have a path of exactly one segment.
///   Multiple levels of directory hierarchy may not be collapsed.
/// * Each child in the directory must have a unique path segment (file name).
///   Note that while the API itself is case-sensitive, the environment where
///   the Action is executed may or may not be case-sensitive. That is, it is
///   legal to call the API with a Directory that has both "Foo" and "foo" as
///   children, but the Action may be rejected by the remote system upon
///   execution.
/// * The files, directories and symlinks in the directory must each be sorted
///   in lexicographical order by path. The path strings must be sorted by code
///   point, equivalently, by UTF-8 bytes.
/// * The [NodeProperties][build.bazel.remote.execution.v2.NodeProperty] of files,
///   directories, and symlinks must be sorted in lexicographical order by
///   property name.
///
/// A `Directory` that obeys the restrictions is said to be in canonical form.
///
/// As an example, the following could be used for a file named `bar` and a
/// directory named `foo` with an executable file named `baz` (hashes shortened
/// for readability):
///
/// ```json
/// // (Directory proto)
/// {
///   files: [
///     {
///       name: "bar",
///       digest: {
///         hash: "4a73bc9d03...",
///         size: 65534
///       },
///       node_properties: [
///         {
///           "name": "MTime",
///           "value": "2017-01-15T01:30:15.01Z"
///         }
///       ]
///     }
///   ],
///   directories: [
///     {
///       name: "foo",
///       digest: {
///         hash: "4cf2eda940...",
///         size: 43
///       }
///     }
///   ]
/// }
///
/// // (Directory proto with hash "4cf2eda940..." and size 43)
/// {
///   files: [
///     {
///       name: "baz",
///       digest: {
///         hash: "b2c941073e...",
///         size: 1294,
///       },
///       is_executable: true
///     }
///   ]
/// }
/// ```
public struct Build_Bazel_Remote_Execution_V2_Directory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The files in the directory.
  public var files: [Build_Bazel_Remote_Execution_V2_FileNode] = []

  /// The subdirectories in the directory.
  public var directories: [Build_Bazel_Remote_Execution_V2_DirectoryNode] = []

  /// The symlinks in the directory.
  public var symlinks: [Build_Bazel_Remote_Execution_V2_SymlinkNode] = []

  public var nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties {
    get {return _nodeProperties ?? Build_Bazel_Remote_Execution_V2_NodeProperties()}
    set {_nodeProperties = newValue}
  }
  /// Returns true if `nodeProperties` has been explicitly set.
  public var hasNodeProperties: Bool {return self._nodeProperties != nil}
  /// Clears the value of `nodeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearNodeProperties() {self._nodeProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties? = nil
}

/// A single property for [FileNodes][build.bazel.remote.execution.v2.FileNode],
/// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode], and
/// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode]. The server is
/// responsible for specifying the property `name`s that it accepts. If
/// permitted by the server, the same `name` may occur multiple times.
public struct Build_Bazel_Remote_Execution_V2_NodeProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The property name.
  public var name: String = String()

  /// The property value.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Node properties for [FileNodes][build.bazel.remote.execution.v2.FileNode],
/// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode], and
/// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode]. The server is
/// responsible for specifying the properties that it accepts.
public struct Build_Bazel_Remote_Execution_V2_NodeProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of string-based
  /// [NodeProperties][build.bazel.remote.execution.v2.NodeProperty].
  public var properties: [Build_Bazel_Remote_Execution_V2_NodeProperty] = []

  /// The file's last modification timestamp.
  public var mtime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _mtime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_mtime = newValue}
  }
  /// Returns true if `mtime` has been explicitly set.
  public var hasMtime: Bool {return self._mtime != nil}
  /// Clears the value of `mtime`. Subsequent reads from it will return its default value.
  public mutating func clearMtime() {self._mtime = nil}

  /// The UNIX file mode, e.g., 0755.
  public var unixMode: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _unixMode ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_unixMode = newValue}
  }
  /// Returns true if `unixMode` has been explicitly set.
  public var hasUnixMode: Bool {return self._unixMode != nil}
  /// Clears the value of `unixMode`. Subsequent reads from it will return its default value.
  public mutating func clearUnixMode() {self._unixMode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mtime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _unixMode: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// A `FileNode` represents a single file and associated metadata.
public struct Build_Bazel_Remote_Execution_V2_FileNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the file.
  public var name: String = String()

  /// The digest of the file's content.
  public var digest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// True if file is executable, false otherwise.
  public var isExecutable: Bool = false

  public var nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties {
    get {return _nodeProperties ?? Build_Bazel_Remote_Execution_V2_NodeProperties()}
    set {_nodeProperties = newValue}
  }
  /// Returns true if `nodeProperties` has been explicitly set.
  public var hasNodeProperties: Bool {return self._nodeProperties != nil}
  /// Clears the value of `nodeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearNodeProperties() {self._nodeProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties? = nil
}

/// A `DirectoryNode` represents a child of a
/// [Directory][build.bazel.remote.execution.v2.Directory] which is itself
/// a `Directory` and its associated metadata.
public struct Build_Bazel_Remote_Execution_V2_DirectoryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the directory.
  public var name: String = String()

  /// The digest of the
  /// [Directory][build.bazel.remote.execution.v2.Directory] object
  /// represented. See [Digest][build.bazel.remote.execution.v2.Digest]
  /// for information about how to take the digest of a proto message.
  public var digest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A `SymlinkNode` represents a symbolic link.
public struct Build_Bazel_Remote_Execution_V2_SymlinkNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the symlink.
  public var name: String = String()

  /// The target path of the symlink. The path separator is a forward slash `/`.
  /// The target path can be relative to the parent directory of the symlink or
  /// it can be an absolute path starting with `/`. Support for absolute paths
  /// can be checked using the [Capabilities][build.bazel.remote.execution.v2.Capabilities]
  /// API. `..` components are allowed anywhere in the target path as logical
  /// canonicalization may lead to different behavior in the presence of
  /// directory symlinks (e.g. `foo/../bar` may not be the same as `bar`).
  /// To reduce potential cache misses, canonicalization is still recommended
  /// where this is possible without impacting correctness.
  public var target: String = String()

  public var nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties {
    get {return _nodeProperties ?? Build_Bazel_Remote_Execution_V2_NodeProperties()}
    set {_nodeProperties = newValue}
  }
  /// Returns true if `nodeProperties` has been explicitly set.
  public var hasNodeProperties: Bool {return self._nodeProperties != nil}
  /// Clears the value of `nodeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearNodeProperties() {self._nodeProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties? = nil
}

/// A content digest. A digest for a given blob consists of the size of the blob
/// and its hash. The hash algorithm to use is defined by the server.
///
/// The size is considered to be an integral part of the digest and cannot be
/// separated. That is, even if the `hash` field is correctly specified but
/// `size_bytes` is not, the server MUST reject the request.
///
/// The reason for including the size in the digest is as follows: in a great
/// many cases, the server needs to know the size of the blob it is about to work
/// with prior to starting an operation with it, such as flattening Merkle tree
/// structures or streaming it to a worker. Technically, the server could
/// implement a separate metadata store, but this results in a significantly more
/// complicated implementation as opposed to having the client specify the size
/// up-front (or storing the size along with the digest in every message where
/// digests are embedded). This does mean that the API leaks some implementation
/// details of (what we consider to be) a reasonable server implementation, but
/// we consider this to be a worthwhile tradeoff.
///
/// When a `Digest` is used to refer to a proto message, it always refers to the
/// message in binary encoded form. To ensure consistent hashing, clients and
/// servers MUST ensure that they serialize messages according to the following
/// rules, even if there are alternate valid encodings for the same message:
///
/// * Fields are serialized in tag order.
/// * There are no unknown fields.
/// * There are no duplicate fields.
/// * Fields are serialized according to the default semantics for their type.
///
/// Most protocol buffer implementations will always follow these rules when
/// serializing, but care should be taken to avoid shortcuts. For instance,
/// concatenating two messages to merge them may produce duplicate fields.
public struct Build_Bazel_Remote_Execution_V2_Digest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash. In the case of SHA-256, it will always be a lowercase hex string
  /// exactly 64 characters long.
  public var hash: String = String()

  /// The size of the blob, in bytes.
  public var sizeBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ExecutedActionMetadata contains details about a completed execution.
public struct Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the worker which ran the execution.
  public var worker: String {
    get {return _storage._worker}
    set {_uniqueStorage()._worker = newValue}
  }

  /// When was the action added to the queue.
  public var queuedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._queuedTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._queuedTimestamp = newValue}
  }
  /// Returns true if `queuedTimestamp` has been explicitly set.
  public var hasQueuedTimestamp: Bool {return _storage._queuedTimestamp != nil}
  /// Clears the value of `queuedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearQueuedTimestamp() {_uniqueStorage()._queuedTimestamp = nil}

  /// When the worker received the action.
  public var workerStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._workerStartTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._workerStartTimestamp = newValue}
  }
  /// Returns true if `workerStartTimestamp` has been explicitly set.
  public var hasWorkerStartTimestamp: Bool {return _storage._workerStartTimestamp != nil}
  /// Clears the value of `workerStartTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerStartTimestamp() {_uniqueStorage()._workerStartTimestamp = nil}

  /// When the worker completed the action, including all stages.
  public var workerCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._workerCompletedTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._workerCompletedTimestamp = newValue}
  }
  /// Returns true if `workerCompletedTimestamp` has been explicitly set.
  public var hasWorkerCompletedTimestamp: Bool {return _storage._workerCompletedTimestamp != nil}
  /// Clears the value of `workerCompletedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerCompletedTimestamp() {_uniqueStorage()._workerCompletedTimestamp = nil}

  /// When the worker started fetching action inputs.
  public var inputFetchStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._inputFetchStartTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._inputFetchStartTimestamp = newValue}
  }
  /// Returns true if `inputFetchStartTimestamp` has been explicitly set.
  public var hasInputFetchStartTimestamp: Bool {return _storage._inputFetchStartTimestamp != nil}
  /// Clears the value of `inputFetchStartTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearInputFetchStartTimestamp() {_uniqueStorage()._inputFetchStartTimestamp = nil}

  /// When the worker finished fetching action inputs.
  public var inputFetchCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._inputFetchCompletedTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._inputFetchCompletedTimestamp = newValue}
  }
  /// Returns true if `inputFetchCompletedTimestamp` has been explicitly set.
  public var hasInputFetchCompletedTimestamp: Bool {return _storage._inputFetchCompletedTimestamp != nil}
  /// Clears the value of `inputFetchCompletedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearInputFetchCompletedTimestamp() {_uniqueStorage()._inputFetchCompletedTimestamp = nil}

  /// When the worker started executing the action command.
  public var executionStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._executionStartTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._executionStartTimestamp = newValue}
  }
  /// Returns true if `executionStartTimestamp` has been explicitly set.
  public var hasExecutionStartTimestamp: Bool {return _storage._executionStartTimestamp != nil}
  /// Clears the value of `executionStartTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionStartTimestamp() {_uniqueStorage()._executionStartTimestamp = nil}

  /// When the worker completed executing the action command.
  public var executionCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._executionCompletedTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._executionCompletedTimestamp = newValue}
  }
  /// Returns true if `executionCompletedTimestamp` has been explicitly set.
  public var hasExecutionCompletedTimestamp: Bool {return _storage._executionCompletedTimestamp != nil}
  /// Clears the value of `executionCompletedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionCompletedTimestamp() {_uniqueStorage()._executionCompletedTimestamp = nil}

  /// When the worker started uploading action outputs.
  public var outputUploadStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._outputUploadStartTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._outputUploadStartTimestamp = newValue}
  }
  /// Returns true if `outputUploadStartTimestamp` has been explicitly set.
  public var hasOutputUploadStartTimestamp: Bool {return _storage._outputUploadStartTimestamp != nil}
  /// Clears the value of `outputUploadStartTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOutputUploadStartTimestamp() {_uniqueStorage()._outputUploadStartTimestamp = nil}

  /// When the worker finished uploading action outputs.
  public var outputUploadCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._outputUploadCompletedTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._outputUploadCompletedTimestamp = newValue}
  }
  /// Returns true if `outputUploadCompletedTimestamp` has been explicitly set.
  public var hasOutputUploadCompletedTimestamp: Bool {return _storage._outputUploadCompletedTimestamp != nil}
  /// Clears the value of `outputUploadCompletedTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOutputUploadCompletedTimestamp() {_uniqueStorage()._outputUploadCompletedTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An ActionResult represents the result of an
/// [Action][build.bazel.remote.execution.v2.Action] being run.
///
/// It is advised that at least one field (for example
/// `ActionResult.execution_metadata.Worker`) have a non-default value, to
/// ensure that the serialized value is non-empty, which can then be used
/// as a basic data sanity check.
public struct Build_Bazel_Remote_Execution_V2_ActionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The output files of the action. For each output file requested in the
  /// `output_files` or `output_paths` field of the Action, if the corresponding
  /// file existed after the action completed, a single entry will be present
  /// either in this field, or the `output_file_symlinks` field if the file was
  /// a symbolic link to another file (`output_symlinks` field after v2.1).
  ///
  /// If an output listed in `output_files` was found, but was a directory rather
  /// than a regular file, the server will return a FAILED_PRECONDITION.
  /// If the action does not produce the requested output, then that output
  /// will be omitted from the list. The server is free to arrange the output
  /// list as desired; clients MUST NOT assume that the output list is sorted.
  public var outputFiles: [Build_Bazel_Remote_Execution_V2_OutputFile] = []

  /// The output files of the action that are symbolic links to other files. Those
  /// may be links to other output files, or input files, or even absolute paths
  /// outside of the working directory, if the server supports
  /// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
  /// For each output file requested in the `output_files` or `output_paths`
  /// field of the Action, if the corresponding file existed after
  /// the action completed, a single entry will be present either in this field,
  /// or in the `output_files` field, if the file was not a symbolic link.
  ///
  /// If an output symbolic link of the same name as listed in `output_files` of
  /// the Command was found, but its target type was not a regular file, the
  /// server will return a FAILED_PRECONDITION.
  /// If the action does not produce the requested output, then that output
  /// will be omitted from the list. The server is free to arrange the output
  /// list as desired; clients MUST NOT assume that the output list is sorted.
  ///
  /// DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API
  /// should still populate this field in addition to `output_symlinks`.
  public var outputFileSymlinks: [Build_Bazel_Remote_Execution_V2_OutputSymlink] = []

  /// New in v2.1: this field will only be populated if the command
  /// `output_paths` field was used, and not the pre v2.1 `output_files` or
  /// `output_directories` fields.
  /// The output paths of the action that are symbolic links to other paths. Those
  /// may be links to other outputs, or inputs, or even absolute paths
  /// outside of the working directory, if the server supports
  /// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
  /// A single entry for each output requested in `output_paths`
  /// field of the Action, if the corresponding path existed after
  /// the action completed and was a symbolic link.
  ///
  /// If the action does not produce a requested output, then that output
  /// will be omitted from the list. The server is free to arrange the output
  /// list as desired; clients MUST NOT assume that the output list is sorted.
  public var outputSymlinks: [Build_Bazel_Remote_Execution_V2_OutputSymlink] = []

  /// The output directories of the action. For each output directory requested
  /// in the `output_directories` or `output_paths` field of the Action, if the
  /// corresponding directory existed after the action completed, a single entry
  /// will be present in the output list, which will contain the digest of a
  /// [Tree][build.bazel.remote.execution.v2.Tree] message containing the
  /// directory tree, and the path equal exactly to the corresponding Action
  /// output_directories member.
  ///
  /// As an example, suppose the Action had an output directory `a/b/dir` and the
  /// execution produced the following contents in `a/b/dir`: a file named `bar`
  /// and a directory named `foo` with an executable file named `baz`. Then,
  /// output_directory will contain (hashes shortened for readability):
  ///
  /// ```json
  /// // OutputDirectory proto:
  /// {
  ///   path: "a/b/dir"
  ///   tree_digest: {
  ///     hash: "4a73bc9d03...",
  ///     size: 55
  ///   }
  /// }
  /// // Tree proto with hash "4a73bc9d03..." and size 55:
  /// {
  ///   root: {
  ///     files: [
  ///       {
  ///         name: "bar",
  ///         digest: {
  ///           hash: "4a73bc9d03...",
  ///           size: 65534
  ///         }
  ///       }
  ///     ],
  ///     directories: [
  ///       {
  ///         name: "foo",
  ///         digest: {
  ///           hash: "4cf2eda940...",
  ///           size: 43
  ///         }
  ///       }
  ///     ]
  ///   }
  ///   children : {
  ///     // (Directory proto with hash "4cf2eda940..." and size 43)
  ///     files: [
  ///       {
  ///         name: "baz",
  ///         digest: {
  ///           hash: "b2c941073e...",
  ///           size: 1294,
  ///         },
  ///         is_executable: true
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  /// If an output of the same name as listed in `output_files` of
  /// the Command was found in `output_directories`, but was not a directory, the
  /// server will return a FAILED_PRECONDITION.
  public var outputDirectories: [Build_Bazel_Remote_Execution_V2_OutputDirectory] = []

  /// The output directories of the action that are symbolic links to other
  /// directories. Those may be links to other output directories, or input
  /// directories, or even absolute paths outside of the working directory,
  /// if the server supports
  /// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
  /// For each output directory requested in the `output_directories` field of
  /// the Action, if the directory existed after the action completed, a
  /// single entry will be present either in this field, or in the
  /// `output_directories` field, if the directory was not a symbolic link.
  ///
  /// If an output of the same name was found, but was a symbolic link to a file
  /// instead of a directory, the server will return a FAILED_PRECONDITION.
  /// If the action does not produce the requested output, then that output
  /// will be omitted from the list. The server is free to arrange the output
  /// list as desired; clients MUST NOT assume that the output list is sorted.
  ///
  /// DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API
  /// should still populate this field in addition to `output_symlinks`.
  public var outputDirectorySymlinks: [Build_Bazel_Remote_Execution_V2_OutputSymlink] = []

  /// The exit code of the command.
  public var exitCode: Int32 = 0

  /// The standard output buffer of the action. The server SHOULD NOT inline
  /// stdout unless requested by the client in the
  /// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
  /// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
  /// would cause the response to exceed message size limits.
  public var stdoutRaw: Data = Data()

  /// The digest for a blob containing the standard output of the action, which
  /// can be retrieved from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  public var stdoutDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _stdoutDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_stdoutDigest = newValue}
  }
  /// Returns true if `stdoutDigest` has been explicitly set.
  public var hasStdoutDigest: Bool {return self._stdoutDigest != nil}
  /// Clears the value of `stdoutDigest`. Subsequent reads from it will return its default value.
  public mutating func clearStdoutDigest() {self._stdoutDigest = nil}

  /// The standard error buffer of the action. The server SHOULD NOT inline
  /// stderr unless requested by the client in the
  /// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
  /// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
  /// would cause the response to exceed message size limits.
  public var stderrRaw: Data = Data()

  /// The digest for a blob containing the standard error of the action, which
  /// can be retrieved from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  public var stderrDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _stderrDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_stderrDigest = newValue}
  }
  /// Returns true if `stderrDigest` has been explicitly set.
  public var hasStderrDigest: Bool {return self._stderrDigest != nil}
  /// Clears the value of `stderrDigest`. Subsequent reads from it will return its default value.
  public mutating func clearStderrDigest() {self._stderrDigest = nil}

  /// The details of the execution that originally produced this result.
  public var executionMetadata: Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata {
    get {return _executionMetadata ?? Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata()}
    set {_executionMetadata = newValue}
  }
  /// Returns true if `executionMetadata` has been explicitly set.
  public var hasExecutionMetadata: Bool {return self._executionMetadata != nil}
  /// Clears the value of `executionMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionMetadata() {self._executionMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stdoutDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _stderrDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _executionMetadata: Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata? = nil
}

/// An `OutputFile` is similar to a
/// [FileNode][build.bazel.remote.execution.v2.FileNode], but it is used as an
/// output in an `ActionResult`. It allows a full file path rather than
/// only a name.
public struct Build_Bazel_Remote_Execution_V2_OutputFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full path of the file relative to the working directory, including the
  /// filename. The path separator is a forward slash `/`. Since this is a
  /// relative path, it MUST NOT begin with a leading forward slash.
  public var path: String = String()

  /// The digest of the file's content.
  public var digest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// True if file is executable, false otherwise.
  public var isExecutable: Bool = false

  /// The contents of the file if inlining was requested. The server SHOULD NOT inline
  /// file contents unless requested by the client in the
  /// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
  /// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
  /// would cause the response to exceed message size limits.
  public var contents: Data = Data()

  public var nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties {
    get {return _nodeProperties ?? Build_Bazel_Remote_Execution_V2_NodeProperties()}
    set {_nodeProperties = newValue}
  }
  /// Returns true if `nodeProperties` has been explicitly set.
  public var hasNodeProperties: Bool {return self._nodeProperties != nil}
  /// Clears the value of `nodeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearNodeProperties() {self._nodeProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties? = nil
}

/// A `Tree` contains all the
/// [Directory][build.bazel.remote.execution.v2.Directory] protos in a
/// single directory Merkle tree, compressed into one message.
public struct Build_Bazel_Remote_Execution_V2_Tree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root directory in the tree.
  public var root: Build_Bazel_Remote_Execution_V2_Directory {
    get {return _root ?? Build_Bazel_Remote_Execution_V2_Directory()}
    set {_root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  public var hasRoot: Bool {return self._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  public mutating func clearRoot() {self._root = nil}

  /// All the child directories: the directories referred to by the root and,
  /// recursively, all its children. In order to reconstruct the directory tree,
  /// the client must take the digests of each of the child directories and then
  /// build up a tree starting from the `root`.
  public var children: [Build_Bazel_Remote_Execution_V2_Directory] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _root: Build_Bazel_Remote_Execution_V2_Directory? = nil
}

/// An `OutputDirectory` is the output in an `ActionResult` corresponding to a
/// directory's full contents rather than a single file.
public struct Build_Bazel_Remote_Execution_V2_OutputDirectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full path of the directory relative to the working directory. The path
  /// separator is a forward slash `/`. Since this is a relative path, it MUST
  /// NOT begin with a leading forward slash. The empty string value is allowed,
  /// and it denotes the entire working directory.
  public var path: String = String()

  /// The digest of the encoded
  /// [Tree][build.bazel.remote.execution.v2.Tree] proto containing the
  /// directory's contents.
  public var treeDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _treeDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_treeDigest = newValue}
  }
  /// Returns true if `treeDigest` has been explicitly set.
  public var hasTreeDigest: Bool {return self._treeDigest != nil}
  /// Clears the value of `treeDigest`. Subsequent reads from it will return its default value.
  public mutating func clearTreeDigest() {self._treeDigest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _treeDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// An `OutputSymlink` is similar to a
/// [Symlink][build.bazel.remote.execution.v2.SymlinkNode], but it is used as an
/// output in an `ActionResult`.
///
/// `OutputSymlink` is binary-compatible with `SymlinkNode`.
public struct Build_Bazel_Remote_Execution_V2_OutputSymlink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full path of the symlink relative to the working directory, including the
  /// filename. The path separator is a forward slash `/`. Since this is a
  /// relative path, it MUST NOT begin with a leading forward slash.
  public var path: String = String()

  /// The target path of the symlink. The path separator is a forward slash `/`.
  /// The target path can be relative to the parent directory of the symlink or
  /// it can be an absolute path starting with `/`. Support for absolute paths
  /// can be checked using the [Capabilities][build.bazel.remote.execution.v2.Capabilities]
  /// API. `..` components are allowed anywhere in the target path.
  public var target: String = String()

  public var nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties {
    get {return _nodeProperties ?? Build_Bazel_Remote_Execution_V2_NodeProperties()}
    set {_nodeProperties = newValue}
  }
  /// Returns true if `nodeProperties` has been explicitly set.
  public var hasNodeProperties: Bool {return self._nodeProperties != nil}
  /// Clears the value of `nodeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearNodeProperties() {self._nodeProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeProperties: Build_Bazel_Remote_Execution_V2_NodeProperties? = nil
}

/// An `ExecutionPolicy` can be used to control the scheduling of the action.
public struct Build_Bazel_Remote_Execution_V2_ExecutionPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The priority (relative importance) of this action. Generally, a lower value
  /// means that the action should be run sooner than actions having a greater
  /// priority value, but the interpretation of a given value is server-
  /// dependent. A priority of 0 means the *default* priority. Priorities may be
  /// positive or negative, and such actions should run later or sooner than
  /// actions having the default priority, respectively. The particular semantics
  /// of this field is up to the server. In particular, every server will have
  /// their own supported range of priorities, and will decide how these map into
  /// scheduling policy.
  public var priority: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A `ResultsCachePolicy` is used for fine-grained control over how action
/// outputs are stored in the CAS and Action Cache.
public struct Build_Bazel_Remote_Execution_V2_ResultsCachePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The priority (relative importance) of this content in the overall cache.
  /// Generally, a lower value means a longer retention time or other advantage,
  /// but the interpretation of a given value is server-dependent. A priority of
  /// 0 means a *default* value, decided by the server.
  ///
  /// The particular semantics of this field is up to the server. In particular,
  /// every server will have their own supported range of priorities, and will
  /// decide how these map into retention/eviction policy.
  public var priority: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [Execution.Execute][build.bazel.remote.execution.v2.Execution.Execute].
public struct Build_Bazel_Remote_Execution_V2_ExecuteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// If true, the action will be executed even if its result is already
  /// present in the [ActionCache][build.bazel.remote.execution.v2.ActionCache].
  /// The execution is still allowed to be merged with other in-flight executions
  /// of the same action, however - semantically, the service MUST only guarantee
  /// that the results of an execution with this field set were not visible
  /// before the corresponding execution request was sent.
  /// Note that actions from execution requests setting this field set are still
  /// eligible to be entered into the action cache upon completion, and services
  /// SHOULD overwrite any existing entries that may exist. This allows
  /// skip_cache_lookup requests to be used as a mechanism for replacing action
  /// cache entries that reference outputs no longer available or that are
  /// poisoned in any way.
  /// If false, the result may be served from the action cache.
  public var skipCacheLookup: Bool = false

  /// The digest of the [Action][build.bazel.remote.execution.v2.Action] to
  /// execute.
  public var actionDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _actionDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_actionDigest = newValue}
  }
  /// Returns true if `actionDigest` has been explicitly set.
  public var hasActionDigest: Bool {return self._actionDigest != nil}
  /// Clears the value of `actionDigest`. Subsequent reads from it will return its default value.
  public mutating func clearActionDigest() {self._actionDigest = nil}

  /// An optional policy for execution of the action.
  /// The server will have a default policy if this is not provided.
  public var executionPolicy: Build_Bazel_Remote_Execution_V2_ExecutionPolicy {
    get {return _executionPolicy ?? Build_Bazel_Remote_Execution_V2_ExecutionPolicy()}
    set {_executionPolicy = newValue}
  }
  /// Returns true if `executionPolicy` has been explicitly set.
  public var hasExecutionPolicy: Bool {return self._executionPolicy != nil}
  /// Clears the value of `executionPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionPolicy() {self._executionPolicy = nil}

  /// An optional policy for the results of this execution in the remote cache.
  /// The server will have a default policy if this is not provided.
  /// This may be applied to both the ActionResult and the associated blobs.
  public var resultsCachePolicy: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy {
    get {return _resultsCachePolicy ?? Build_Bazel_Remote_Execution_V2_ResultsCachePolicy()}
    set {_resultsCachePolicy = newValue}
  }
  /// Returns true if `resultsCachePolicy` has been explicitly set.
  public var hasResultsCachePolicy: Bool {return self._resultsCachePolicy != nil}
  /// Clears the value of `resultsCachePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearResultsCachePolicy() {self._resultsCachePolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _actionDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  fileprivate var _executionPolicy: Build_Bazel_Remote_Execution_V2_ExecutionPolicy? = nil
  fileprivate var _resultsCachePolicy: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy? = nil
}

/// A `LogFile` is a log stored in the CAS.
public struct Build_Bazel_Remote_Execution_V2_LogFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The digest of the log contents.
  public var digest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// This is a hint as to the purpose of the log, and is set to true if the log
  /// is human-readable text that can be usefully displayed to a user, and false
  /// otherwise. For instance, if a command-line client wishes to print the
  /// server logs to the terminal for a failed action, this allows it to avoid
  /// displaying a binary file.
  public var humanReadable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// The response message for
/// [Execution.Execute][build.bazel.remote.execution.v2.Execution.Execute],
/// which will be contained in the [response
/// field][google.longrunning.Operation.response] of the
/// [Operation][google.longrunning.Operation].
public struct Build_Bazel_Remote_Execution_V2_ExecuteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of the action.
  public var result: Build_Bazel_Remote_Execution_V2_ActionResult {
    get {return _storage._result ?? Build_Bazel_Remote_Execution_V2_ActionResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_uniqueStorage()._result = nil}

  /// True if the result was served from cache, false if it was executed.
  public var cachedResult: Bool {
    get {return _storage._cachedResult}
    set {_uniqueStorage()._cachedResult = newValue}
  }

  /// If the status has a code other than `OK`, it indicates that the action did
  /// not finish execution. For example, if the operation times out during
  /// execution, the status will have a `DEADLINE_EXCEEDED` code. Servers MUST
  /// use this field for errors in execution, rather than the error field on the
  /// `Operation` object.
  ///
  /// If the status code is other than `OK`, then the result MUST NOT be cached.
  /// For an error status, the `result` field is optional; the server may
  /// populate the output-, stdout-, and stderr-related fields if it has any
  /// information available, such as the stdout and stderr of a timed-out action.
  public var status: Google_Rpc_Status {
    get {return _storage._status ?? Google_Rpc_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// An optional list of additional log outputs the server wishes to provide. A
  /// server can use this to return execution-specific logs however it wishes.
  /// This is intended primarily to make it easier for users to debug issues that
  /// may be outside of the actual job execution, such as by identifying the
  /// worker executing the action or by providing logs from the worker's setup
  /// phase. The keys SHOULD be human readable so that a client can display them
  /// to a user.
  public var serverLogs: Dictionary<String,Build_Bazel_Remote_Execution_V2_LogFile> {
    get {return _storage._serverLogs}
    set {_uniqueStorage()._serverLogs = newValue}
  }

  /// Freeform informational message with details on the execution of the action
  /// that may be displayed to the user upon failure or when requested explicitly.
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The current stage of action execution.
public struct Build_Bazel_Remote_Execution_V2_ExecutionStage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Value: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid value.
    case unknown // = 0

    /// Checking the result against the cache.
    case cacheCheck // = 1

    /// Currently idle, awaiting a free machine to execute.
    case queued // = 2

    /// Currently being executed by a worker.
    case executing // = 3

    /// Finished execution.
    case completed // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .cacheCheck
      case 2: self = .queued
      case 3: self = .executing
      case 4: self = .completed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .cacheCheck: return 1
      case .queued: return 2
      case .executing: return 3
      case .completed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Build_Bazel_Remote_Execution_V2_ExecutionStage.Value: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Build_Bazel_Remote_Execution_V2_ExecutionStage.Value] = [
    .unknown,
    .cacheCheck,
    .queued,
    .executing,
    .completed,
  ]
}

#endif  // swift(>=4.2)

/// Metadata about an ongoing
/// [execution][build.bazel.remote.execution.v2.Execution.Execute], which
/// will be contained in the [metadata
/// field][google.longrunning.Operation.response] of the
/// [Operation][google.longrunning.Operation].
public struct Build_Bazel_Remote_Execution_V2_ExecuteOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The current stage of execution.
  public var stage: Build_Bazel_Remote_Execution_V2_ExecutionStage.Value = .unknown

  /// The digest of the [Action][build.bazel.remote.execution.v2.Action]
  /// being executed.
  public var actionDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _actionDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_actionDigest = newValue}
  }
  /// Returns true if `actionDigest` has been explicitly set.
  public var hasActionDigest: Bool {return self._actionDigest != nil}
  /// Clears the value of `actionDigest`. Subsequent reads from it will return its default value.
  public mutating func clearActionDigest() {self._actionDigest = nil}

  /// If set, the client can use this resource name with
  /// [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
  /// standard output from the endpoint hosting streamed responses.
  public var stdoutStreamName: String = String()

  /// If set, the client can use this resource name with
  /// [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
  /// standard error from the endpoint hosting streamed responses.
  public var stderrStreamName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _actionDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A request message for
/// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution].
public struct Build_Bazel_Remote_Execution_V2_WaitExecutionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the [Operation][google.longrunning.Operation]
  /// returned by [Execute][build.bazel.remote.execution.v2.Execution.Execute].
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [ActionCache.GetActionResult][build.bazel.remote.execution.v2.ActionCache.GetActionResult].
public struct Build_Bazel_Remote_Execution_V2_GetActionResultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The digest of the [Action][build.bazel.remote.execution.v2.Action]
  /// whose result is requested.
  public var actionDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _actionDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_actionDigest = newValue}
  }
  /// Returns true if `actionDigest` has been explicitly set.
  public var hasActionDigest: Bool {return self._actionDigest != nil}
  /// Clears the value of `actionDigest`. Subsequent reads from it will return its default value.
  public mutating func clearActionDigest() {self._actionDigest = nil}

  /// A hint to the server to request inlining stdout in the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] message.
  public var inlineStdout: Bool = false

  /// A hint to the server to request inlining stderr in the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] message.
  public var inlineStderr: Bool = false

  /// A hint to the server to inline the contents of the listed output files.
  /// Each path needs to exactly match one file path in either `output_paths` or
  /// `output_files` (DEPRECATED since v2.1) in the
  /// [Command][build.bazel.remote.execution.v2.Command] message.
  public var inlineOutputFiles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _actionDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A request message for
/// [ActionCache.UpdateActionResult][build.bazel.remote.execution.v2.ActionCache.UpdateActionResult].
public struct Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String {
    get {return _storage._instanceName}
    set {_uniqueStorage()._instanceName = newValue}
  }

  /// The digest of the [Action][build.bazel.remote.execution.v2.Action]
  /// whose result is being uploaded.
  public var actionDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _storage._actionDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_uniqueStorage()._actionDigest = newValue}
  }
  /// Returns true if `actionDigest` has been explicitly set.
  public var hasActionDigest: Bool {return _storage._actionDigest != nil}
  /// Clears the value of `actionDigest`. Subsequent reads from it will return its default value.
  public mutating func clearActionDigest() {_uniqueStorage()._actionDigest = nil}

  /// The [ActionResult][build.bazel.remote.execution.v2.ActionResult]
  /// to store in the cache.
  public var actionResult: Build_Bazel_Remote_Execution_V2_ActionResult {
    get {return _storage._actionResult ?? Build_Bazel_Remote_Execution_V2_ActionResult()}
    set {_uniqueStorage()._actionResult = newValue}
  }
  /// Returns true if `actionResult` has been explicitly set.
  public var hasActionResult: Bool {return _storage._actionResult != nil}
  /// Clears the value of `actionResult`. Subsequent reads from it will return its default value.
  public mutating func clearActionResult() {_uniqueStorage()._actionResult = nil}

  /// An optional policy for the results of this execution in the remote cache.
  /// The server will have a default policy if this is not provided.
  /// This may be applied to both the ActionResult and the associated blobs.
  public var resultsCachePolicy: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy {
    get {return _storage._resultsCachePolicy ?? Build_Bazel_Remote_Execution_V2_ResultsCachePolicy()}
    set {_uniqueStorage()._resultsCachePolicy = newValue}
  }
  /// Returns true if `resultsCachePolicy` has been explicitly set.
  public var hasResultsCachePolicy: Bool {return _storage._resultsCachePolicy != nil}
  /// Clears the value of `resultsCachePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearResultsCachePolicy() {_uniqueStorage()._resultsCachePolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A request message for
/// [ContentAddressableStorage.FindMissingBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.FindMissingBlobs].
public struct Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// A list of the blobs to check.
  public var blobDigests: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for
/// [ContentAddressableStorage.FindMissingBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.FindMissingBlobs].
public struct Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of the blobs requested *not* present in the storage.
  public var missingBlobDigests: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [ContentAddressableStorage.BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
public struct Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The individual upload requests.
  public var requests: [Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest.Request] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A request corresponding to a single blob that the client wants to upload.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The digest of the blob. This MUST be the digest of `data`.
    public var digest: Build_Bazel_Remote_Execution_V2_Digest {
      get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
      set {_digest = newValue}
    }
    /// Returns true if `digest` has been explicitly set.
    public var hasDigest: Bool {return self._digest != nil}
    /// Clears the value of `digest`. Subsequent reads from it will return its default value.
    public mutating func clearDigest() {self._digest = nil}

    /// The raw binary data.
    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
  }

  public init() {}
}

/// A response message for
/// [ContentAddressableStorage.BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
public struct Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The responses to the requests.
  public var responses: [Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A response corresponding to a single blob that the client tried to upload.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The blob digest to which this response corresponds.
    public var digest: Build_Bazel_Remote_Execution_V2_Digest {
      get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
      set {_digest = newValue}
    }
    /// Returns true if `digest` has been explicitly set.
    public var hasDigest: Bool {return self._digest != nil}
    /// Clears the value of `digest`. Subsequent reads from it will return its default value.
    public mutating func clearDigest() {self._digest = nil}

    /// The result of attempting to upload that blob.
    public var status: Google_Rpc_Status {
      get {return _status ?? Google_Rpc_Status()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
    fileprivate var _status: Google_Rpc_Status? = nil
  }

  public init() {}
}

/// A request message for
/// [ContentAddressableStorage.BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
public struct Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The individual blob digests.
  public var digests: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for
/// [ContentAddressableStorage.BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
public struct Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The responses to the requests.
  public var responses: [Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse.Response] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A response corresponding to a single blob that the client tried to download.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The digest to which this response corresponds.
    public var digest: Build_Bazel_Remote_Execution_V2_Digest {
      get {return _digest ?? Build_Bazel_Remote_Execution_V2_Digest()}
      set {_digest = newValue}
    }
    /// Returns true if `digest` has been explicitly set.
    public var hasDigest: Bool {return self._digest != nil}
    /// Clears the value of `digest`. Subsequent reads from it will return its default value.
    public mutating func clearDigest() {self._digest = nil}

    /// The raw binary data.
    public var data: Data = Data()

    /// The result of attempting to download that blob.
    public var status: Google_Rpc_Status {
      get {return _status ?? Google_Rpc_Status()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _digest: Build_Bazel_Remote_Execution_V2_Digest? = nil
    fileprivate var _status: Google_Rpc_Status? = nil
  }

  public init() {}
}

/// A request message for
/// [ContentAddressableStorage.GetTree][build.bazel.remote.execution.v2.ContentAddressableStorage.GetTree].
public struct Build_Bazel_Remote_Execution_V2_GetTreeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The digest of the root, which must be an encoded
  /// [Directory][build.bazel.remote.execution.v2.Directory] message
  /// stored in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  public var rootDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _rootDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_rootDigest = newValue}
  }
  /// Returns true if `rootDigest` has been explicitly set.
  public var hasRootDigest: Bool {return self._rootDigest != nil}
  /// Clears the value of `rootDigest`. Subsequent reads from it will return its default value.
  public mutating func clearRootDigest() {self._rootDigest = nil}

  /// A maximum page size to request. If present, the server will request no more
  /// than this many items. Regardless of whether a page size is specified, the
  /// server may place its own limit on the number of items to be returned and
  /// require the client to retrieve more items using a subsequent request.
  public var pageSize: Int32 = 0

  /// A page token, which must be a value received in a previous
  /// [GetTreeResponse][build.bazel.remote.execution.v2.GetTreeResponse].
  /// If present, the server will use that token as an offset, returning only
  /// that page and the ones that succeed it.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A response message for
/// [ContentAddressableStorage.GetTree][build.bazel.remote.execution.v2.ContentAddressableStorage.GetTree].
public struct Build_Bazel_Remote_Execution_V2_GetTreeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The directories descended from the requested root.
  public var directories: [Build_Bazel_Remote_Execution_V2_Directory] = []

  /// If present, signifies that there are more results which the client can
  /// retrieve by passing this as the page_token in a subsequent
  /// [request][build.bazel.remote.execution.v2.GetTreeRequest].
  /// If empty, signifies that this is the last page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [Capabilities.GetCapabilities][build.bazel.remote.execution.v2.Capabilities.GetCapabilities].
public struct Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for
/// [Capabilities.GetCapabilities][build.bazel.remote.execution.v2.Capabilities.GetCapabilities].
public struct Build_Bazel_Remote_Execution_V2_ServerCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Capabilities of the remote cache system.
  public var cacheCapabilities: Build_Bazel_Remote_Execution_V2_CacheCapabilities {
    get {return _storage._cacheCapabilities ?? Build_Bazel_Remote_Execution_V2_CacheCapabilities()}
    set {_uniqueStorage()._cacheCapabilities = newValue}
  }
  /// Returns true if `cacheCapabilities` has been explicitly set.
  public var hasCacheCapabilities: Bool {return _storage._cacheCapabilities != nil}
  /// Clears the value of `cacheCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCacheCapabilities() {_uniqueStorage()._cacheCapabilities = nil}

  /// Capabilities of the remote execution system.
  public var executionCapabilities: Build_Bazel_Remote_Execution_V2_ExecutionCapabilities {
    get {return _storage._executionCapabilities ?? Build_Bazel_Remote_Execution_V2_ExecutionCapabilities()}
    set {_uniqueStorage()._executionCapabilities = newValue}
  }
  /// Returns true if `executionCapabilities` has been explicitly set.
  public var hasExecutionCapabilities: Bool {return _storage._executionCapabilities != nil}
  /// Clears the value of `executionCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionCapabilities() {_uniqueStorage()._executionCapabilities = nil}

  /// Earliest RE API version supported, including deprecated versions.
  public var deprecatedApiVersion: Build_Bazel_Semver_SemVer {
    get {return _storage._deprecatedApiVersion ?? Build_Bazel_Semver_SemVer()}
    set {_uniqueStorage()._deprecatedApiVersion = newValue}
  }
  /// Returns true if `deprecatedApiVersion` has been explicitly set.
  public var hasDeprecatedApiVersion: Bool {return _storage._deprecatedApiVersion != nil}
  /// Clears the value of `deprecatedApiVersion`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedApiVersion() {_uniqueStorage()._deprecatedApiVersion = nil}

  /// Earliest non-deprecated RE API version supported.
  public var lowApiVersion: Build_Bazel_Semver_SemVer {
    get {return _storage._lowApiVersion ?? Build_Bazel_Semver_SemVer()}
    set {_uniqueStorage()._lowApiVersion = newValue}
  }
  /// Returns true if `lowApiVersion` has been explicitly set.
  public var hasLowApiVersion: Bool {return _storage._lowApiVersion != nil}
  /// Clears the value of `lowApiVersion`. Subsequent reads from it will return its default value.
  public mutating func clearLowApiVersion() {_uniqueStorage()._lowApiVersion = nil}

  /// Latest RE API version supported.
  public var highApiVersion: Build_Bazel_Semver_SemVer {
    get {return _storage._highApiVersion ?? Build_Bazel_Semver_SemVer()}
    set {_uniqueStorage()._highApiVersion = newValue}
  }
  /// Returns true if `highApiVersion` has been explicitly set.
  public var hasHighApiVersion: Bool {return _storage._highApiVersion != nil}
  /// Clears the value of `highApiVersion`. Subsequent reads from it will return its default value.
  public mutating func clearHighApiVersion() {_uniqueStorage()._highApiVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The digest function used for converting values into keys for CAS and Action
/// Cache.
public struct Build_Bazel_Remote_Execution_V2_DigestFunction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Value: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// It is an error for the server to return this value.
    case unknown // = 0

    /// The SHA-256 digest function.
    case sha256 // = 1

    /// The SHA-1 digest function.
    case sha1 // = 2

    /// The MD5 digest function.
    case md5 // = 3

    /// The Microsoft "VSO-Hash" paged SHA256 digest function.
    /// See https://github.com/microsoft/BuildXL/blob/master/Documentation/Specs/PagedHash.md .
    case vso // = 4

    /// The SHA-384 digest function.
    case sha384 // = 5

    /// The SHA-512 digest function.
    case sha512 // = 6

    /// Murmur3 128-bit digest function, x64 variant. Note that this is not a
    /// cryptographic hash function and its collision properties are not strongly guaranteed.
    /// See https://github.com/aappleby/smhasher/wiki/MurmurHash3 .
    case murmur3 // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sha256
      case 2: self = .sha1
      case 3: self = .md5
      case 4: self = .vso
      case 5: self = .sha384
      case 6: self = .sha512
      case 7: self = .murmur3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sha256: return 1
      case .sha1: return 2
      case .md5: return 3
      case .vso: return 4
      case .sha384: return 5
      case .sha512: return 6
      case .murmur3: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Build_Bazel_Remote_Execution_V2_DigestFunction.Value: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Build_Bazel_Remote_Execution_V2_DigestFunction.Value] = [
    .unknown,
    .sha256,
    .sha1,
    .md5,
    .vso,
    .sha384,
    .sha512,
    .murmur3,
  ]
}

#endif  // swift(>=4.2)

/// Describes the server/instance capabilities for updating the action cache.
public struct Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updateEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Allowed values for priority in
/// [ResultsCachePolicy][build.bazel.remoteexecution.v2.ResultsCachePolicy] and
/// [ExecutionPolicy][build.bazel.remoteexecution.v2.ResultsCachePolicy]
/// Used for querying both cache and execution valid priority ranges.
public struct Build_Bazel_Remote_Execution_V2_PriorityCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var priorities: [Build_Bazel_Remote_Execution_V2_PriorityCapabilities.PriorityRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Supported range of priorities, including boundaries.
  public struct PriorityRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum numeric value for this priority range, which represents the
    /// most urgent task or longest retained item.
    public var minPriority: Int32 = 0

    /// The maximum numeric value for this priority range, which represents the
    /// least urgent task or shortest retained item.
    public var maxPriority: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Describes how the server treats absolute symlink targets.
public struct Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Value: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid value.
    case unknown // = 0

    /// Server will return an `INVALID_ARGUMENT` on input symlinks with absolute
    /// targets.
    /// If an action tries to create an output symlink with an absolute target, a
    /// `FAILED_PRECONDITION` will be returned.
    case disallowed // = 1

    /// Server will allow symlink targets to escape the input root tree, possibly
    /// resulting in non-hermetic builds.
    case allowed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .disallowed
      case 2: self = .allowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .disallowed: return 1
      case .allowed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy.Value: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy.Value] = [
    .unknown,
    .disallowed,
    .allowed,
  ]
}

#endif  // swift(>=4.2)

/// Capabilities of the remote cache system.
public struct Build_Bazel_Remote_Execution_V2_CacheCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All the digest functions supported by the remote cache.
  /// Remote cache may support multiple digest functions simultaneously.
  public var digestFunction: [Build_Bazel_Remote_Execution_V2_DigestFunction.Value] = []

  /// Capabilities for updating the action cache.
  public var actionCacheUpdateCapabilities: Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities {
    get {return _actionCacheUpdateCapabilities ?? Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities()}
    set {_actionCacheUpdateCapabilities = newValue}
  }
  /// Returns true if `actionCacheUpdateCapabilities` has been explicitly set.
  public var hasActionCacheUpdateCapabilities: Bool {return self._actionCacheUpdateCapabilities != nil}
  /// Clears the value of `actionCacheUpdateCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearActionCacheUpdateCapabilities() {self._actionCacheUpdateCapabilities = nil}

  /// Supported cache priority range for both CAS and ActionCache.
  public var cachePriorityCapabilities: Build_Bazel_Remote_Execution_V2_PriorityCapabilities {
    get {return _cachePriorityCapabilities ?? Build_Bazel_Remote_Execution_V2_PriorityCapabilities()}
    set {_cachePriorityCapabilities = newValue}
  }
  /// Returns true if `cachePriorityCapabilities` has been explicitly set.
  public var hasCachePriorityCapabilities: Bool {return self._cachePriorityCapabilities != nil}
  /// Clears the value of `cachePriorityCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCachePriorityCapabilities() {self._cachePriorityCapabilities = nil}

  /// Maximum total size of blobs to be uploaded/downloaded using
  /// batch methods. A value of 0 means no limit is set, although
  /// in practice there will always be a message size limitation
  /// of the protocol in use, e.g. GRPC.
  public var maxBatchTotalSizeBytes: Int64 = 0

  /// Whether absolute symlink targets are supported.
  public var symlinkAbsolutePathStrategy: Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy.Value = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _actionCacheUpdateCapabilities: Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities? = nil
  fileprivate var _cachePriorityCapabilities: Build_Bazel_Remote_Execution_V2_PriorityCapabilities? = nil
}

/// Capabilities of the remote execution system.
public struct Build_Bazel_Remote_Execution_V2_ExecutionCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remote execution may only support a single digest function.
  public var digestFunction: Build_Bazel_Remote_Execution_V2_DigestFunction.Value = .unknown

  /// Whether remote execution is enabled for the particular server/instance.
  public var execEnabled: Bool = false

  /// Supported execution priority range.
  public var executionPriorityCapabilities: Build_Bazel_Remote_Execution_V2_PriorityCapabilities {
    get {return _executionPriorityCapabilities ?? Build_Bazel_Remote_Execution_V2_PriorityCapabilities()}
    set {_executionPriorityCapabilities = newValue}
  }
  /// Returns true if `executionPriorityCapabilities` has been explicitly set.
  public var hasExecutionPriorityCapabilities: Bool {return self._executionPriorityCapabilities != nil}
  /// Clears the value of `executionPriorityCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionPriorityCapabilities() {self._executionPriorityCapabilities = nil}

  /// Supported node properties.
  public var supportedNodeProperties: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _executionPriorityCapabilities: Build_Bazel_Remote_Execution_V2_PriorityCapabilities? = nil
}

/// Details for the tool used to call the API.
public struct Build_Bazel_Remote_Execution_V2_ToolDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the tool, e.g. bazel.
  public var toolName: String = String()

  /// Version of the tool used for the request, e.g. 5.0.3.
  public var toolVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An optional Metadata to attach to any RPC request to tell the server about an
/// external context of the request. The server may use this for logging or other
/// purposes. To use it, the client attaches the header to the call using the
/// canonical proto serialization:
///
/// * name: `build.bazel.remote.execution.v2.requestmetadata-bin`
/// * contents: the base64 encoded binary `RequestMetadata` message.
/// Note: the gRPC library serializes binary headers encoded in base 64 by
/// default (https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).
/// Therefore, if the gRPC library is used to pass/retrieve this
/// metadata, the user may ignore the base64 encoding and assume it is simply
/// serialized as a binary message.
public struct Build_Bazel_Remote_Execution_V2_RequestMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The details for the tool invoking the requests.
  public var toolDetails: Build_Bazel_Remote_Execution_V2_ToolDetails {
    get {return _toolDetails ?? Build_Bazel_Remote_Execution_V2_ToolDetails()}
    set {_toolDetails = newValue}
  }
  /// Returns true if `toolDetails` has been explicitly set.
  public var hasToolDetails: Bool {return self._toolDetails != nil}
  /// Clears the value of `toolDetails`. Subsequent reads from it will return its default value.
  public mutating func clearToolDetails() {self._toolDetails = nil}

  /// An identifier that ties multiple requests to the same action.
  /// For example, multiple requests to the CAS, Action Cache, and Execution
  /// API are used in order to compile foo.cc.
  public var actionID: String = String()

  /// An identifier that ties multiple actions together to a final result.
  /// For example, multiple actions are required to build and run foo_test.
  public var toolInvocationID: String = String()

  /// An identifier to tie multiple tool invocations together. For example,
  /// runs of foo_test, bar_test and baz_test on a post-submit of a given patch.
  public var correlatedInvocationsID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toolDetails: Build_Bazel_Remote_Execution_V2_ToolDetails? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build.bazel.remote.execution.v2"

extension Build_Bazel_Remote_Execution_V2_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_digest"),
    2: .standard(proto: "input_root_digest"),
    6: .same(proto: "timeout"),
    7: .standard(proto: "do_not_cache"),
    9: .same(proto: "salt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandDigest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputRootDigest) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.doNotCache) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.salt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commandDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._inputRootDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.doNotCache != false {
      try visitor.visitSingularBoolField(value: self.doNotCache, fieldNumber: 7)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularBytesField(value: self.salt, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Action, rhs: Build_Bazel_Remote_Execution_V2_Action) -> Bool {
    if lhs._commandDigest != rhs._commandDigest {return false}
    if lhs._inputRootDigest != rhs._inputRootDigest {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.doNotCache != rhs.doNotCache {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arguments"),
    2: .standard(proto: "environment_variables"),
    3: .standard(proto: "output_files"),
    4: .standard(proto: "output_directories"),
    7: .standard(proto: "output_paths"),
    5: .same(proto: "platform"),
    6: .standard(proto: "working_directory"),
    8: .standard(proto: "output_node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.environmentVariables) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.outputFiles) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.outputDirectories) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.workingDirectory) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.outputPaths) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.outputNodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 1)
    }
    if !self.environmentVariables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.environmentVariables, fieldNumber: 2)
    }
    if !self.outputFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputFiles, fieldNumber: 3)
    }
    if !self.outputDirectories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputDirectories, fieldNumber: 4)
    }
    if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.outputPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputPaths, fieldNumber: 7)
    }
    if !self.outputNodeProperties.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputNodeProperties, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Command, rhs: Build_Bazel_Remote_Execution_V2_Command) -> Bool {
    if lhs.arguments != rhs.arguments {return false}
    if lhs.environmentVariables != rhs.environmentVariables {return false}
    if lhs.outputFiles != rhs.outputFiles {return false}
    if lhs.outputDirectories != rhs.outputDirectories {return false}
    if lhs.outputPaths != rhs.outputPaths {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.outputNodeProperties != rhs.outputNodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Command.EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_Command.protoMessageName + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Command.EnvironmentVariable, rhs: Build_Bazel_Remote_Execution_V2_Command.EnvironmentVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Platform, rhs: Build_Bazel_Remote_Execution_V2_Platform) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Platform.Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_Platform.protoMessageName + ".Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Platform.Property, rhs: Build_Bazel_Remote_Execution_V2_Platform.Property) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Directory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Directory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "directories"),
    3: .same(proto: "symlinks"),
    5: .standard(proto: "node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.directories) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.symlinks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._nodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.directories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directories, fieldNumber: 2)
    }
    if !self.symlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symlinks, fieldNumber: 3)
    }
    if let v = self._nodeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Directory, rhs: Build_Bazel_Remote_Execution_V2_Directory) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.directories != rhs.directories {return false}
    if lhs.symlinks != rhs.symlinks {return false}
    if lhs._nodeProperties != rhs._nodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_NodeProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeProperty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_NodeProperty, rhs: Build_Bazel_Remote_Execution_V2_NodeProperty) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_NodeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
    2: .same(proto: "mtime"),
    3: .standard(proto: "unix_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mtime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unixMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    if let v = self._mtime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._unixMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_NodeProperties, rhs: Build_Bazel_Remote_Execution_V2_NodeProperties) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs._mtime != rhs._mtime {return false}
    if lhs._unixMode != rhs._unixMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_FileNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "digest"),
    4: .standard(proto: "is_executable"),
    6: .standard(proto: "node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isExecutable) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.isExecutable != false {
      try visitor.visitSingularBoolField(value: self.isExecutable, fieldNumber: 4)
    }
    if let v = self._nodeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_FileNode, rhs: Build_Bazel_Remote_Execution_V2_FileNode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.isExecutable != rhs.isExecutable {return false}
    if lhs._nodeProperties != rhs._nodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_DirectoryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectoryNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_DirectoryNode, rhs: Build_Bazel_Remote_Execution_V2_DirectoryNode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_SymlinkNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymlinkNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "target"),
    4: .standard(proto: "node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    if let v = self._nodeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_SymlinkNode, rhs: Build_Bazel_Remote_Execution_V2_SymlinkNode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.target != rhs.target {return false}
    if lhs._nodeProperties != rhs._nodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Digest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Digest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Digest, rhs: Build_Bazel_Remote_Execution_V2_Digest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutedActionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worker"),
    2: .standard(proto: "queued_timestamp"),
    3: .standard(proto: "worker_start_timestamp"),
    4: .standard(proto: "worker_completed_timestamp"),
    5: .standard(proto: "input_fetch_start_timestamp"),
    6: .standard(proto: "input_fetch_completed_timestamp"),
    7: .standard(proto: "execution_start_timestamp"),
    8: .standard(proto: "execution_completed_timestamp"),
    9: .standard(proto: "output_upload_start_timestamp"),
    10: .standard(proto: "output_upload_completed_timestamp"),
  ]

  fileprivate class _StorageClass {
    var _worker: String = String()
    var _queuedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _workerStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _workerCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _inputFetchStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _inputFetchCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _executionStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _executionCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _outputUploadStartTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _outputUploadCompletedTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _worker = source._worker
      _queuedTimestamp = source._queuedTimestamp
      _workerStartTimestamp = source._workerStartTimestamp
      _workerCompletedTimestamp = source._workerCompletedTimestamp
      _inputFetchStartTimestamp = source._inputFetchStartTimestamp
      _inputFetchCompletedTimestamp = source._inputFetchCompletedTimestamp
      _executionStartTimestamp = source._executionStartTimestamp
      _executionCompletedTimestamp = source._executionCompletedTimestamp
      _outputUploadStartTimestamp = source._outputUploadStartTimestamp
      _outputUploadCompletedTimestamp = source._outputUploadCompletedTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._worker) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._queuedTimestamp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workerStartTimestamp) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workerCompletedTimestamp) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._inputFetchStartTimestamp) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._inputFetchCompletedTimestamp) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._executionStartTimestamp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._executionCompletedTimestamp) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._outputUploadStartTimestamp) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._outputUploadCompletedTimestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._worker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._worker, fieldNumber: 1)
      }
      if let v = _storage._queuedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._workerStartTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._workerCompletedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._inputFetchStartTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._inputFetchCompletedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._executionStartTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._executionCompletedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._outputUploadStartTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._outputUploadCompletedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata, rhs: Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._queuedTimestamp != rhs_storage._queuedTimestamp {return false}
        if _storage._workerStartTimestamp != rhs_storage._workerStartTimestamp {return false}
        if _storage._workerCompletedTimestamp != rhs_storage._workerCompletedTimestamp {return false}
        if _storage._inputFetchStartTimestamp != rhs_storage._inputFetchStartTimestamp {return false}
        if _storage._inputFetchCompletedTimestamp != rhs_storage._inputFetchCompletedTimestamp {return false}
        if _storage._executionStartTimestamp != rhs_storage._executionStartTimestamp {return false}
        if _storage._executionCompletedTimestamp != rhs_storage._executionCompletedTimestamp {return false}
        if _storage._outputUploadStartTimestamp != rhs_storage._outputUploadStartTimestamp {return false}
        if _storage._outputUploadCompletedTimestamp != rhs_storage._outputUploadCompletedTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ActionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "output_files"),
    10: .standard(proto: "output_file_symlinks"),
    12: .standard(proto: "output_symlinks"),
    3: .standard(proto: "output_directories"),
    11: .standard(proto: "output_directory_symlinks"),
    4: .standard(proto: "exit_code"),
    5: .standard(proto: "stdout_raw"),
    6: .standard(proto: "stdout_digest"),
    7: .standard(proto: "stderr_raw"),
    8: .standard(proto: "stderr_digest"),
    9: .standard(proto: "execution_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputFiles) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputDirectories) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.stdoutRaw) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stdoutDigest) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.stderrRaw) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._stderrDigest) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._executionMetadata) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.outputFileSymlinks) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.outputDirectorySymlinks) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.outputSymlinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputFiles, fieldNumber: 2)
    }
    if !self.outputDirectories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputDirectories, fieldNumber: 3)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 4)
    }
    if !self.stdoutRaw.isEmpty {
      try visitor.visitSingularBytesField(value: self.stdoutRaw, fieldNumber: 5)
    }
    if let v = self._stdoutDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.stderrRaw.isEmpty {
      try visitor.visitSingularBytesField(value: self.stderrRaw, fieldNumber: 7)
    }
    if let v = self._stderrDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._executionMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.outputFileSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputFileSymlinks, fieldNumber: 10)
    }
    if !self.outputDirectorySymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputDirectorySymlinks, fieldNumber: 11)
    }
    if !self.outputSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputSymlinks, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ActionResult, rhs: Build_Bazel_Remote_Execution_V2_ActionResult) -> Bool {
    if lhs.outputFiles != rhs.outputFiles {return false}
    if lhs.outputFileSymlinks != rhs.outputFileSymlinks {return false}
    if lhs.outputSymlinks != rhs.outputSymlinks {return false}
    if lhs.outputDirectories != rhs.outputDirectories {return false}
    if lhs.outputDirectorySymlinks != rhs.outputDirectorySymlinks {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.stdoutRaw != rhs.stdoutRaw {return false}
    if lhs._stdoutDigest != rhs._stdoutDigest {return false}
    if lhs.stderrRaw != rhs.stderrRaw {return false}
    if lhs._stderrDigest != rhs._stderrDigest {return false}
    if lhs._executionMetadata != rhs._executionMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_OutputFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "digest"),
    4: .standard(proto: "is_executable"),
    5: .same(proto: "contents"),
    7: .standard(proto: "node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isExecutable) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.contents) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._nodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.isExecutable != false {
      try visitor.visitSingularBoolField(value: self.isExecutable, fieldNumber: 4)
    }
    if !self.contents.isEmpty {
      try visitor.visitSingularBytesField(value: self.contents, fieldNumber: 5)
    }
    if let v = self._nodeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_OutputFile, rhs: Build_Bazel_Remote_Execution_V2_OutputFile) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.isExecutable != rhs.isExecutable {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs._nodeProperties != rhs._nodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_Tree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .same(proto: "children"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._root) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._root {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_Tree, rhs: Build_Bazel_Remote_Execution_V2_Tree) -> Bool {
    if lhs._root != rhs._root {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_OutputDirectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputDirectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    3: .standard(proto: "tree_digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._treeDigest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if let v = self._treeDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_OutputDirectory, rhs: Build_Bazel_Remote_Execution_V2_OutputDirectory) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._treeDigest != rhs._treeDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_OutputSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputSymlink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "target"),
    4: .standard(proto: "node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    if let v = self._nodeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_OutputSymlink, rhs: Build_Bazel_Remote_Execution_V2_OutputSymlink) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.target != rhs.target {return false}
    if lhs._nodeProperties != rhs._nodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecutionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "priority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecutionPolicy, rhs: Build_Bazel_Remote_Execution_V2_ExecutionPolicy) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ResultsCachePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResultsCachePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "priority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy, rhs: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecuteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    3: .standard(proto: "skip_cache_lookup"),
    6: .standard(proto: "action_digest"),
    7: .standard(proto: "execution_policy"),
    8: .standard(proto: "results_cache_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipCacheLookup) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._actionDigest) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._executionPolicy) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._resultsCachePolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if self.skipCacheLookup != false {
      try visitor.visitSingularBoolField(value: self.skipCacheLookup, fieldNumber: 3)
    }
    if let v = self._actionDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._executionPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._resultsCachePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecuteRequest, rhs: Build_Bazel_Remote_Execution_V2_ExecuteRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.skipCacheLookup != rhs.skipCacheLookup {return false}
    if lhs._actionDigest != rhs._actionDigest {return false}
    if lhs._executionPolicy != rhs._executionPolicy {return false}
    if lhs._resultsCachePolicy != rhs._resultsCachePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_LogFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .standard(proto: "human_readable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.humanReadable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.humanReadable != false {
      try visitor.visitSingularBoolField(value: self.humanReadable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_LogFile, rhs: Build_Bazel_Remote_Execution_V2_LogFile) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs.humanReadable != rhs.humanReadable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "cached_result"),
    3: .same(proto: "status"),
    4: .standard(proto: "server_logs"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _result: Build_Bazel_Remote_Execution_V2_ActionResult? = nil
    var _cachedResult: Bool = false
    var _status: Google_Rpc_Status? = nil
    var _serverLogs: Dictionary<String,Build_Bazel_Remote_Execution_V2_LogFile> = [:]
    var _message: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
      _cachedResult = source._cachedResult
      _status = source._status
      _serverLogs = source._serverLogs
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._cachedResult) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Build_Bazel_Remote_Execution_V2_LogFile>.self, value: &_storage._serverLogs) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._cachedResult != false {
        try visitor.visitSingularBoolField(value: _storage._cachedResult, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._serverLogs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Build_Bazel_Remote_Execution_V2_LogFile>.self, value: _storage._serverLogs, fieldNumber: 4)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecuteResponse, rhs: Build_Bazel_Remote_Execution_V2_ExecuteResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        if _storage._cachedResult != rhs_storage._cachedResult {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._serverLogs != rhs_storage._serverLogs {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecutionStage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionStage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecutionStage, rhs: Build_Bazel_Remote_Execution_V2_ExecutionStage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecutionStage.Value: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CACHE_CHECK"),
    2: .same(proto: "QUEUED"),
    3: .same(proto: "EXECUTING"),
    4: .same(proto: "COMPLETED"),
  ]
}

extension Build_Bazel_Remote_Execution_V2_ExecuteOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stage"),
    2: .standard(proto: "action_digest"),
    3: .standard(proto: "stdout_stream_name"),
    4: .standard(proto: "stderr_stream_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actionDigest) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stdoutStreamName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.stderrStreamName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stage != .unknown {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 1)
    }
    if let v = self._actionDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.stdoutStreamName.isEmpty {
      try visitor.visitSingularStringField(value: self.stdoutStreamName, fieldNumber: 3)
    }
    if !self.stderrStreamName.isEmpty {
      try visitor.visitSingularStringField(value: self.stderrStreamName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecuteOperationMetadata, rhs: Build_Bazel_Remote_Execution_V2_ExecuteOperationMetadata) -> Bool {
    if lhs.stage != rhs.stage {return false}
    if lhs._actionDigest != rhs._actionDigest {return false}
    if lhs.stdoutStreamName != rhs.stdoutStreamName {return false}
    if lhs.stderrStreamName != rhs.stderrStreamName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_WaitExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitExecutionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, rhs: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_GetActionResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActionResultRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .standard(proto: "action_digest"),
    3: .standard(proto: "inline_stdout"),
    4: .standard(proto: "inline_stderr"),
    5: .standard(proto: "inline_output_files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actionDigest) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.inlineStdout) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.inlineStderr) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.inlineOutputFiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if let v = self._actionDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.inlineStdout != false {
      try visitor.visitSingularBoolField(value: self.inlineStdout, fieldNumber: 3)
    }
    if self.inlineStderr != false {
      try visitor.visitSingularBoolField(value: self.inlineStderr, fieldNumber: 4)
    }
    if !self.inlineOutputFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inlineOutputFiles, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_GetActionResultRequest, rhs: Build_Bazel_Remote_Execution_V2_GetActionResultRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs._actionDigest != rhs._actionDigest {return false}
    if lhs.inlineStdout != rhs.inlineStdout {return false}
    if lhs.inlineStderr != rhs.inlineStderr {return false}
    if lhs.inlineOutputFiles != rhs.inlineOutputFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActionResultRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .standard(proto: "action_digest"),
    3: .standard(proto: "action_result"),
    4: .standard(proto: "results_cache_policy"),
  ]

  fileprivate class _StorageClass {
    var _instanceName: String = String()
    var _actionDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
    var _actionResult: Build_Bazel_Remote_Execution_V2_ActionResult? = nil
    var _resultsCachePolicy: Build_Bazel_Remote_Execution_V2_ResultsCachePolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _instanceName = source._instanceName
      _actionDigest = source._actionDigest
      _actionResult = source._actionResult
      _resultsCachePolicy = source._resultsCachePolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._instanceName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._actionDigest) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._actionResult) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._resultsCachePolicy) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._instanceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instanceName, fieldNumber: 1)
      }
      if let v = _storage._actionDigest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._actionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._resultsCachePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, rhs: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instanceName != rhs_storage._instanceName {return false}
        if _storage._actionDigest != rhs_storage._actionDigest {return false}
        if _storage._actionResult != rhs_storage._actionResult {return false}
        if _storage._resultsCachePolicy != rhs_storage._resultsCachePolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindMissingBlobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .standard(proto: "blob_digests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blobDigests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.blobDigests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blobDigests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, rhs: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.blobDigests != rhs.blobDigests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindMissingBlobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "missing_blob_digests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.missingBlobDigests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.missingBlobDigests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.missingBlobDigests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse, rhs: Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse) -> Bool {
    if lhs.missingBlobDigests != rhs.missingBlobDigests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchUpdateBlobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, rhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest.Request, rhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest.Request) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchUpdateBlobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse, rhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse.Response, rhs: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse.Response) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchReadBlobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "digests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.digests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.digests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.digests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, rhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.digests != rhs.digests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchReadBlobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse, rhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .same(proto: "data"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse.Response, rhs: Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse.Response) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs.data != rhs.data {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_GetTreeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTreeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .standard(proto: "root_digest"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rootDigest) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if let v = self._rootDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_GetTreeRequest, rhs: Build_Bazel_Remote_Execution_V2_GetTreeRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs._rootDigest != rhs._rootDigest {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_GetTreeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTreeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directories"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.directories) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.directories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directories, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_GetTreeResponse, rhs: Build_Bazel_Remote_Execution_V2_GetTreeResponse) -> Bool {
    if lhs.directories != rhs.directories {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCapabilitiesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, rhs: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ServerCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_capabilities"),
    2: .standard(proto: "execution_capabilities"),
    3: .standard(proto: "deprecated_api_version"),
    4: .standard(proto: "low_api_version"),
    5: .standard(proto: "high_api_version"),
  ]

  fileprivate class _StorageClass {
    var _cacheCapabilities: Build_Bazel_Remote_Execution_V2_CacheCapabilities? = nil
    var _executionCapabilities: Build_Bazel_Remote_Execution_V2_ExecutionCapabilities? = nil
    var _deprecatedApiVersion: Build_Bazel_Semver_SemVer? = nil
    var _lowApiVersion: Build_Bazel_Semver_SemVer? = nil
    var _highApiVersion: Build_Bazel_Semver_SemVer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cacheCapabilities = source._cacheCapabilities
      _executionCapabilities = source._executionCapabilities
      _deprecatedApiVersion = source._deprecatedApiVersion
      _lowApiVersion = source._lowApiVersion
      _highApiVersion = source._highApiVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._cacheCapabilities) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._executionCapabilities) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._deprecatedApiVersion) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lowApiVersion) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._highApiVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cacheCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._executionCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._deprecatedApiVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lowApiVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._highApiVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ServerCapabilities, rhs: Build_Bazel_Remote_Execution_V2_ServerCapabilities) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cacheCapabilities != rhs_storage._cacheCapabilities {return false}
        if _storage._executionCapabilities != rhs_storage._executionCapabilities {return false}
        if _storage._deprecatedApiVersion != rhs_storage._deprecatedApiVersion {return false}
        if _storage._lowApiVersion != rhs_storage._lowApiVersion {return false}
        if _storage._highApiVersion != rhs_storage._highApiVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_DigestFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DigestFunction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_DigestFunction, rhs: Build_Bazel_Remote_Execution_V2_DigestFunction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_DigestFunction.Value: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SHA256"),
    2: .same(proto: "SHA1"),
    3: .same(proto: "MD5"),
    4: .same(proto: "VSO"),
    5: .same(proto: "SHA384"),
    6: .same(proto: "SHA512"),
    7: .same(proto: "MURMUR3"),
  ]
}

extension Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionCacheUpdateCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.updateEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updateEnabled != false {
      try visitor.visitSingularBoolField(value: self.updateEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities, rhs: Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities) -> Bool {
    if lhs.updateEnabled != rhs.updateEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_PriorityCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PriorityCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "priorities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priorities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priorities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priorities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_PriorityCapabilities, rhs: Build_Bazel_Remote_Execution_V2_PriorityCapabilities) -> Bool {
    if lhs.priorities != rhs.priorities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_PriorityCapabilities.PriorityRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Build_Bazel_Remote_Execution_V2_PriorityCapabilities.protoMessageName + ".PriorityRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_priority"),
    2: .standard(proto: "max_priority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minPriority) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxPriority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPriority != 0 {
      try visitor.visitSingularInt32Field(value: self.minPriority, fieldNumber: 1)
    }
    if self.maxPriority != 0 {
      try visitor.visitSingularInt32Field(value: self.maxPriority, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_PriorityCapabilities.PriorityRange, rhs: Build_Bazel_Remote_Execution_V2_PriorityCapabilities.PriorityRange) -> Bool {
    if lhs.minPriority != rhs.minPriority {return false}
    if lhs.maxPriority != rhs.maxPriority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymlinkAbsolutePathStrategy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy, rhs: Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy.Value: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DISALLOWED"),
    2: .same(proto: "ALLOWED"),
  ]
}

extension Build_Bazel_Remote_Execution_V2_CacheCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CacheCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "digest_function"),
    2: .standard(proto: "action_cache_update_capabilities"),
    3: .standard(proto: "cache_priority_capabilities"),
    4: .standard(proto: "max_batch_total_size_bytes"),
    5: .standard(proto: "symlink_absolute_path_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.digestFunction) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actionCacheUpdateCapabilities) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cachePriorityCapabilities) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.maxBatchTotalSizeBytes) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.symlinkAbsolutePathStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.digestFunction.isEmpty {
      try visitor.visitPackedEnumField(value: self.digestFunction, fieldNumber: 1)
    }
    if let v = self._actionCacheUpdateCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._cachePriorityCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.maxBatchTotalSizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxBatchTotalSizeBytes, fieldNumber: 4)
    }
    if self.symlinkAbsolutePathStrategy != .unknown {
      try visitor.visitSingularEnumField(value: self.symlinkAbsolutePathStrategy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_CacheCapabilities, rhs: Build_Bazel_Remote_Execution_V2_CacheCapabilities) -> Bool {
    if lhs.digestFunction != rhs.digestFunction {return false}
    if lhs._actionCacheUpdateCapabilities != rhs._actionCacheUpdateCapabilities {return false}
    if lhs._cachePriorityCapabilities != rhs._cachePriorityCapabilities {return false}
    if lhs.maxBatchTotalSizeBytes != rhs.maxBatchTotalSizeBytes {return false}
    if lhs.symlinkAbsolutePathStrategy != rhs.symlinkAbsolutePathStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ExecutionCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "digest_function"),
    2: .standard(proto: "exec_enabled"),
    3: .standard(proto: "execution_priority_capabilities"),
    4: .standard(proto: "supported_node_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.digestFunction) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.execEnabled) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._executionPriorityCapabilities) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.supportedNodeProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.digestFunction != .unknown {
      try visitor.visitSingularEnumField(value: self.digestFunction, fieldNumber: 1)
    }
    if self.execEnabled != false {
      try visitor.visitSingularBoolField(value: self.execEnabled, fieldNumber: 2)
    }
    if let v = self._executionPriorityCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.supportedNodeProperties.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supportedNodeProperties, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ExecutionCapabilities, rhs: Build_Bazel_Remote_Execution_V2_ExecutionCapabilities) -> Bool {
    if lhs.digestFunction != rhs.digestFunction {return false}
    if lhs.execEnabled != rhs.execEnabled {return false}
    if lhs._executionPriorityCapabilities != rhs._executionPriorityCapabilities {return false}
    if lhs.supportedNodeProperties != rhs.supportedNodeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_ToolDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_name"),
    2: .standard(proto: "tool_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toolName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toolVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolName.isEmpty {
      try visitor.visitSingularStringField(value: self.toolName, fieldNumber: 1)
    }
    if !self.toolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.toolVersion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_ToolDetails, rhs: Build_Bazel_Remote_Execution_V2_ToolDetails) -> Bool {
    if lhs.toolName != rhs.toolName {return false}
    if lhs.toolVersion != rhs.toolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Execution_V2_RequestMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_details"),
    2: .standard(proto: "action_id"),
    3: .standard(proto: "tool_invocation_id"),
    4: .standard(proto: "correlated_invocations_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._toolDetails) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toolInvocationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.correlatedInvocationsID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._toolDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 2)
    }
    if !self.toolInvocationID.isEmpty {
      try visitor.visitSingularStringField(value: self.toolInvocationID, fieldNumber: 3)
    }
    if !self.correlatedInvocationsID.isEmpty {
      try visitor.visitSingularStringField(value: self.correlatedInvocationsID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Execution_V2_RequestMetadata, rhs: Build_Bazel_Remote_Execution_V2_RequestMetadata) -> Bool {
    if lhs._toolDetails != rhs._toolDetails {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.toolInvocationID != rhs.toolInvocationID {return false}
    if lhs.correlatedInvocationsID != rhs.correlatedInvocationsID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
