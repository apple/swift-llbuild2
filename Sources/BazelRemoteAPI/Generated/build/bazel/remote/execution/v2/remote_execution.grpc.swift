//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: build/bazel/remote/execution/v2/remote_execution.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


/// The Remote Execution API is used to execute an
/// [Action][build.bazel.remote.execution.v2.Action] on the remote
/// workers.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// Usage: instantiate `Build_Bazel_Remote_Execution_V2_ExecutionClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ExecutionClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Execution_V2_ExecutionClientInterceptorFactoryProtocol? { get }

  func execute(
    _ request: Build_Bazel_Remote_Execution_V2_ExecuteRequest,
    callOptions: CallOptions?,
    handler: @escaping (Google_Longrunning_Operation) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation>

  func waitExecution(
    _ request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest,
    callOptions: CallOptions?,
    handler: @escaping (Google_Longrunning_Operation) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation>
}

extension Build_Bazel_Remote_Execution_V2_ExecutionClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.execution.v2.Execution"
  }

  /// Execute an action remotely.
  ///
  /// In order to execute an action, the client must first upload all of the
  /// inputs, the
  /// [Command][build.bazel.remote.execution.v2.Command] to run, and the
  /// [Action][build.bazel.remote.execution.v2.Action] into the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  /// It then calls `Execute` with an `action_digest` referring to them. The
  /// server will run the action and eventually return the result.
  ///
  /// The input `Action`'s fields MUST meet the various canonicalization
  /// requirements specified in the documentation for their types so that it has
  /// the same digest as other logically equivalent `Action`s. The server MAY
  /// enforce the requirements and return errors if a non-canonical input is
  /// received. It MAY also proceed without verifying some or all of the
  /// requirements, such as for performance reasons. If the server does not
  /// verify the requirement, then it will treat the `Action` as distinct from
  /// another logically equivalent action if they hash differently.
  ///
  /// Returns a stream of
  /// [google.longrunning.Operation][google.longrunning.Operation] messages
  /// describing the resulting execution, with eventual `response`
  /// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
  /// `metadata` on the operation is of type
  /// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
  ///
  /// If the client remains connected after the first response is returned after
  /// the server, then updates are streamed as if the client had called
  /// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
  /// until the execution completes or the request reaches an error. The
  /// operation can also be queried using [Operations
  /// API][google.longrunning.Operations.GetOperation].
  ///
  /// The server NEED NOT implement other methods or functionality of the
  /// Operations API.
  ///
  /// Errors discovered during creation of the `Operation` will be reported
  /// as gRPC Status errors, while errors that occurred while running the
  /// action will be reported in the `status` field of the `ExecuteResponse`. The
  /// server MUST NOT set the `error` field of the `Operation` proto.
  /// The possible errors include:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
  ///   action requested, such as a missing input or command or no worker being
  ///   available. The client may be able to fix the errors and retry.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
  ///   the action.
  /// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
  ///   occupied (and the server does not support a queue), the action could not
  ///   be started. The client should retry.
  /// * `INTERNAL`: An internal error occurred in the execution engine or the
  ///   worker.
  /// * `DEADLINE_EXCEEDED`: The execution timed out.
  /// * `CANCELLED`: The operation was cancelled by the client. This status is
  ///   only possible if the server implements the Operations API CancelOperation
  ///   method, and it was called for the current execution.
  ///
  /// In the case of a missing input or command, the server SHOULD additionally
  /// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
  /// where, for each requested blob not present in the CAS, there is a
  /// `Violation` with a `type` of `MISSING` and a `subject` of
  /// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
  ///
  /// The server does not need to guarantee that a call to this method leads to
  /// at most one execution of the action. The server MAY execute the action
  /// multiple times, potentially in parallel. These redundant executions MAY
  /// continue to run, even if the operation is completed.
  ///
  /// - Parameters:
  ///   - request: Request to send to Execute.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func execute(
    _ request: Build_Bazel_Remote_Execution_V2_ExecuteRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Google_Longrunning_Operation) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation> {
    return self.makeServerStreamingCall(
      path: "/build.bazel.remote.execution.v2.Execution/Execute",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExecuteInterceptors() ?? [],
      handler: handler
    )
  }

  /// Wait for an execution operation to complete. When the client initially
  /// makes the request, the server immediately responds with the current status
  /// of the execution. The server will leave the request stream open until the
  /// operation completes, and then respond with the completed operation. The
  /// server MAY choose to stream additional updates as execution progresses,
  /// such as to provide an update as to the state of the execution.
  ///
  /// - Parameters:
  ///   - request: Request to send to WaitExecution.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func waitExecution(
    _ request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Google_Longrunning_Operation) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation> {
    return self.makeServerStreamingCall(
      path: "/build.bazel.remote.execution.v2.Execution/WaitExecution",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWaitExecutionInterceptors() ?? [],
      handler: handler
    )
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ExecutionClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'execute'.
  func makeExecuteInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation>]

  /// - Returns: Interceptors to use when invoking 'waitExecution'.
  func makeWaitExecutionInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation>]
}

public final class Build_Bazel_Remote_Execution_V2_ExecutionClient: Build_Bazel_Remote_Execution_V2_ExecutionClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Execution_V2_ExecutionClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.execution.v2.Execution service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Execution_V2_ExecutionClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The action cache API is used to query whether a given action has already been
/// performed and, if so, retrieve its result. Unlike the
/// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage],
/// which addresses blobs by their own content, the action cache addresses the
/// [ActionResult][build.bazel.remote.execution.v2.ActionResult] by a
/// digest of the encoded [Action][build.bazel.remote.execution.v2.Action]
/// which produced them.
///
/// The lifetime of entries in the action cache is implementation-specific, but
/// the server SHOULD assume that more recently used entries are more likely to
/// be used again.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// Usage: instantiate `Build_Bazel_Remote_Execution_V2_ActionCacheClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ActionCacheClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Execution_V2_ActionCacheClientInterceptorFactoryProtocol? { get }

  func getActionResult(
    _ request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>

  func updateActionResult(
    _ request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>
}

extension Build_Bazel_Remote_Execution_V2_ActionCacheClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.execution.v2.ActionCache"
  }

  /// Retrieve a cached execution result.
  ///
  /// Implementations SHOULD ensure that any blobs referenced from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// are available at the time of returning the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
  /// for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
  /// if necessary and applicable.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetActionResult.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getActionResult(
    _ request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.ActionCache/GetActionResult",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetActionResultInterceptors() ?? []
    )
  }

  /// Upload a new execution result.
  ///
  /// In order to allow the server to perform access control based on the type of
  /// action, and to assist with client debugging, the client MUST first upload
  /// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
  /// result, along with its
  /// [Command][build.bazel.remote.execution.v2.Command], into the
  /// `ContentAddressableStorage`.
  ///
  /// Server implementations MAY modify the
  /// `UpdateActionResultRequest.action_result` and return an equivalent value.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
  ///   action result, such as a missing command or action.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
  ///   entry to the cache.
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateActionResult.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateActionResult(
    _ request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.ActionCache/UpdateActionResult",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateActionResultInterceptors() ?? []
    )
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ActionCacheClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'getActionResult'.
  func makeGetActionResultInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>]

  /// - Returns: Interceptors to use when invoking 'updateActionResult'.
  func makeUpdateActionResultInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>]
}

public final class Build_Bazel_Remote_Execution_V2_ActionCacheClient: Build_Bazel_Remote_Execution_V2_ActionCacheClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Execution_V2_ActionCacheClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.execution.v2.ActionCache service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Execution_V2_ActionCacheClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The CAS (content-addressable storage) is used to store the inputs to and
/// outputs from the execution service. Each piece of content is addressed by the
/// digest of its binary data.
///
/// Most of the binary data stored in the CAS is opaque to the execution engine,
/// and is only used as a communication medium. In order to build an
/// [Action][build.bazel.remote.execution.v2.Action],
/// however, the client will need to also upload the
/// [Command][build.bazel.remote.execution.v2.Command] and input root
/// [Directory][build.bazel.remote.execution.v2.Directory] for the Action.
/// The Command and Directory messages must be marshalled to wire format and then
/// uploaded under the hash as with any other piece of content. In practice, the
/// input root directory is likely to refer to other Directories in its
/// hierarchy, which must also each be uploaded on their own.
///
/// For small file uploads the client should group them together and call
/// [BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
///
/// For large uploads, the client must use the
/// [Write method][google.bytestream.ByteStream.Write] of the ByteStream API.
///
/// For uncompressed data, The `WriteRequest.resource_name` is of the following form:
/// `{instance_name}/uploads/{uuid}/blobs/{hash}/{size}{/optional_metadata}`
///
/// Where:
/// * `instance_name` is an identifier, possibly containing multiple path
///   segments, used to distinguish between the various instances on the server,
///   in a manner defined by the server. If it is the empty path, the leading
///   slash is omitted, so that  the `resource_name` becomes
///   `uploads/{uuid}/blobs/{hash}/{size}{/optional_metadata}`.
///   To simplify parsing, a path segment cannot equal any of the following
///   keywords: `blobs`, `uploads`, `actions`, `actionResults`, `operations`,
///   `capabilities` or `compressed-blobs`.
/// * `uuid` is a version 4 UUID generated by the client, used to avoid
///   collisions between concurrent uploads of the same data. Clients MAY
///   reuse the same `uuid` for uploading different blobs.
/// * `hash` and `size` refer to the [Digest][build.bazel.remote.execution.v2.Digest]
///   of the data being uploaded.
/// * `optional_metadata` is implementation specific data, which clients MAY omit.
///   Servers MAY ignore this metadata.
///
/// Data can alternatively be uploaded in compressed form, with the following
/// `WriteRequest.resource_name` form:
/// `{instance_name}/uploads/{uuid}/compressed-blobs/{compressor}/{uncompressed_hash}/{uncompressed_size}{/optional_metadata}`
///
/// Where:
/// * `instance_name`, `uuid` and `optional_metadata` are defined as above.
/// * `compressor` is a lowercase string form of a `Compressor.Value` enum
///   other than `identity`, which is supported by the server and advertised in
///   [CacheCapabilities.supported_compressor][build.bazel.remote.execution.v2.CacheCapabilities.supported_compressor].
/// * `uncompressed_hash` and `uncompressed_size` refer to the
///   [Digest][build.bazel.remote.execution.v2.Digest] of the data being
///   uploaded, once uncompressed. Servers MUST verify that these match
///   the uploaded data once uncompressed, and MUST return an
///   `INVALID_ARGUMENT` error in the case of mismatch.
///
/// Note that when writing compressed blobs, the `WriteRequest.write_offset` in
/// the initial request in a stream refers to the offset in the uncompressed form
/// of the blob. In subsequent requests, `WriteRequest.write_offset` MUST be the
/// sum of the first request's 'WriteRequest.write_offset' and the total size of
/// all the compressed data bundles in the previous requests.
/// Note that this mixes an uncompressed offset with a compressed byte length,
/// which is nonsensical, but it is done to fit the semantics of the existing
/// ByteStream protocol.
///
/// Uploads of the same data MAY occur concurrently in any form, compressed or
/// uncompressed.
///
/// Clients SHOULD NOT use gRPC-level compression for ByteStream API `Write`
/// calls of compressed blobs, since this would compress already-compressed data.
///
/// When attempting an upload, if another client has already completed the upload
/// (which may occur in the middle of a single upload if another client uploads
/// the same blob concurrently), the request will terminate immediately with
/// a response whose `committed_size` is the full size of the uploaded file
/// (regardless of how much data was transmitted by the client). If the client
/// completes the upload but the
/// [Digest][build.bazel.remote.execution.v2.Digest] does not match, an
/// `INVALID_ARGUMENT` error will be returned. In either case, the client should
/// not attempt to retry the upload.
///
/// Small downloads can be grouped and requested in a batch via
/// [BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
///
/// For large downloads, the client must use the
/// [Read method][google.bytestream.ByteStream.Read] of the ByteStream API.
///
/// For uncompressed data, The `ReadRequest.resource_name` is of the following form:
/// `{instance_name}/blobs/{hash}/{size}`
/// Where `instance_name`, `hash` and `size` are defined as for uploads.
///
/// Data can alternatively be downloaded in compressed form, with the following
/// `ReadRequest.resource_name` form:
/// `{instance_name}/compressed-blobs/{compressor}/{uncompressed_hash}/{uncompressed_size}`
///
/// Where:
/// * `instance_name` and `compressor` are defined as for uploads.
/// * `uncompressed_hash` and `uncompressed_size` refer to the
///   [Digest][build.bazel.remote.execution.v2.Digest] of the data being
///   downloaded, once uncompressed. Clients MUST verify that these match
///   the downloaded data once uncompressed, and take appropriate steps in
///   the case of failure such as retrying a limited number of times or
///   surfacing an error to the user.
///
/// When downloading compressed blobs:
/// * `ReadRequest.read_offset` refers to the offset in the uncompressed form
///   of the blob.
/// * Servers MUST return `INVALID_ARGUMENT` if `ReadRequest.read_limit` is
///   non-zero.
/// * Servers MAY use any compression level they choose, including different
///   levels for different blobs (e.g. choosing a level designed for maximum
///   speed for data known to be incompressible).
/// * Clients SHOULD NOT use gRPC-level compression, since this would compress
///   already-compressed data.
///
/// Servers MUST be able to provide data for all recently advertised blobs in
/// each of the compression formats that the server supports, as well as in
/// uncompressed form.
///
/// The lifetime of entries in the CAS is implementation specific, but it SHOULD
/// be long enough to allow for newly-added and recently looked-up entries to be
/// used in subsequent calls (e.g. to
/// [Execute][build.bazel.remote.execution.v2.Execution.Execute]).
///
/// Servers MUST behave as though empty blobs are always available, even if they
/// have not been uploaded. Clients MAY optimize away the uploading or
/// downloading of empty blobs.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// Usage: instantiate `Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientInterceptorFactoryProtocol? { get }

  func findMissingBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>

  func batchUpdateBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>

  func batchReadBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>

  func getTree(
    _ request: Build_Bazel_Remote_Execution_V2_GetTreeRequest,
    callOptions: CallOptions?,
    handler: @escaping (Build_Bazel_Remote_Execution_V2_GetTreeResponse) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse>
}

extension Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.execution.v2.ContentAddressableStorage"
  }

  /// Determine if blobs are present in the CAS.
  ///
  /// Clients can use this API before uploading blobs to determine which ones are
  /// already present in the CAS and do not need to be uploaded again.
  ///
  /// Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
  /// applicable.
  ///
  /// There are no method-specific errors.
  ///
  /// - Parameters:
  ///   - request: Request to send to FindMissingBlobs.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func findMissingBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/FindMissingBlobs",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFindMissingBlobsInterceptors() ?? []
    )
  }

  /// Upload many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be uploaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or uploaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Write` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to upload more than the
  ///   server supported limit.
  ///
  /// Individual requests may return the following errors, additionally:
  ///
  /// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
  /// * `INVALID_ARGUMENT`: The
  /// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
  /// provided data.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchUpdateBlobs.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchUpdateBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchUpdateBlobs",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchUpdateBlobsInterceptors() ?? []
    )
  }

  /// Download many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be downloaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or downloaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Read` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to read more than the
  ///   server supported limit.
  ///
  /// Every error on individual read will be returned in the corresponding digest
  /// status.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchReadBlobs.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchReadBlobs(
    _ request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchReadBlobs",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchReadBlobsInterceptors() ?? []
    )
  }

  /// Fetch the entire directory tree rooted at a node.
  ///
  /// This request must be targeted at a
  /// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// (CAS). The server will enumerate the `Directory` tree recursively and
  /// return every node descended from the root.
  ///
  /// The GetTreeRequest.page_token parameter can be used to skip ahead in
  /// the stream (e.g. when retrying a partially completed and aborted request),
  /// by setting it to a value taken from GetTreeResponse.next_page_token of the
  /// last successfully processed GetTreeResponse).
  ///
  /// The exact traversal order is unspecified and, unless retrieving subsequent
  /// pages from an earlier request, is not guaranteed to be stable across
  /// multiple invocations of `GetTree`.
  ///
  /// If part of the tree is missing from the CAS, the server will return the
  /// portion present and omit the rest.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested tree root is not present in the CAS.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetTree.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func getTree(
    _ request: Build_Bazel_Remote_Execution_V2_GetTreeRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Build_Bazel_Remote_Execution_V2_GetTreeResponse) -> Void
  ) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse> {
    return self.makeServerStreamingCall(
      path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/GetTree",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTreeInterceptors() ?? [],
      handler: handler
    )
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'findMissingBlobs'.
  func makeFindMissingBlobsInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>]

  /// - Returns: Interceptors to use when invoking 'batchUpdateBlobs'.
  func makeBatchUpdateBlobsInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>]

  /// - Returns: Interceptors to use when invoking 'batchReadBlobs'.
  func makeBatchReadBlobsInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>]

  /// - Returns: Interceptors to use when invoking 'getTree'.
  func makeGetTreeInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse>]
}

public final class Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClient: Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.execution.v2.ContentAddressableStorage service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The Capabilities service may be used by remote execution clients to query
/// various server properties, in order to self-configure or return meaningful
/// error messages.
///
/// The query may include a particular `instance_name`, in which case the values
/// returned will pertain to that instance.
///
/// Usage: instantiate `Build_Bazel_Remote_Execution_V2_CapabilitiesClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Execution_V2_CapabilitiesClientInterceptorFactoryProtocol? { get }

  func getCapabilities(
    _ request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities>
}

extension Build_Bazel_Remote_Execution_V2_CapabilitiesClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.execution.v2.Capabilities"
  }

  /// GetCapabilities returns the server capabilities configuration of the
  /// remote endpoint.
  /// Only the capabilities of the services supported by the endpoint will
  /// be returned:
  /// * Execution + CAS + Action Cache endpoints should return both
  ///   CacheCapabilities and ExecutionCapabilities.
  /// * Execution only endpoints should return ExecutionCapabilities.
  /// * CAS + Action Cache only endpoints should return CacheCapabilities.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetCapabilities.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getCapabilities(
    _ request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.execution.v2.Capabilities/GetCapabilities",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetCapabilitiesInterceptors() ?? []
    )
  }
}

public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'getCapabilities'.
  func makeGetCapabilitiesInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities>]
}

public final class Build_Bazel_Remote_Execution_V2_CapabilitiesClient: Build_Bazel_Remote_Execution_V2_CapabilitiesClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Execution_V2_CapabilitiesClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.execution.v2.Capabilities service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Execution_V2_CapabilitiesClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The Remote Execution API is used to execute an
/// [Action][build.bazel.remote.execution.v2.Action] on the remote
/// workers.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ExecutionProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Execution_V2_ExecutionServerInterceptorFactoryProtocol? { get }

  /// Execute an action remotely.
  ///
  /// In order to execute an action, the client must first upload all of the
  /// inputs, the
  /// [Command][build.bazel.remote.execution.v2.Command] to run, and the
  /// [Action][build.bazel.remote.execution.v2.Action] into the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  /// It then calls `Execute` with an `action_digest` referring to them. The
  /// server will run the action and eventually return the result.
  ///
  /// The input `Action`'s fields MUST meet the various canonicalization
  /// requirements specified in the documentation for their types so that it has
  /// the same digest as other logically equivalent `Action`s. The server MAY
  /// enforce the requirements and return errors if a non-canonical input is
  /// received. It MAY also proceed without verifying some or all of the
  /// requirements, such as for performance reasons. If the server does not
  /// verify the requirement, then it will treat the `Action` as distinct from
  /// another logically equivalent action if they hash differently.
  ///
  /// Returns a stream of
  /// [google.longrunning.Operation][google.longrunning.Operation] messages
  /// describing the resulting execution, with eventual `response`
  /// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
  /// `metadata` on the operation is of type
  /// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
  ///
  /// If the client remains connected after the first response is returned after
  /// the server, then updates are streamed as if the client had called
  /// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
  /// until the execution completes or the request reaches an error. The
  /// operation can also be queried using [Operations
  /// API][google.longrunning.Operations.GetOperation].
  ///
  /// The server NEED NOT implement other methods or functionality of the
  /// Operations API.
  ///
  /// Errors discovered during creation of the `Operation` will be reported
  /// as gRPC Status errors, while errors that occurred while running the
  /// action will be reported in the `status` field of the `ExecuteResponse`. The
  /// server MUST NOT set the `error` field of the `Operation` proto.
  /// The possible errors include:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
  ///   action requested, such as a missing input or command or no worker being
  ///   available. The client may be able to fix the errors and retry.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
  ///   the action.
  /// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
  ///   occupied (and the server does not support a queue), the action could not
  ///   be started. The client should retry.
  /// * `INTERNAL`: An internal error occurred in the execution engine or the
  ///   worker.
  /// * `DEADLINE_EXCEEDED`: The execution timed out.
  /// * `CANCELLED`: The operation was cancelled by the client. This status is
  ///   only possible if the server implements the Operations API CancelOperation
  ///   method, and it was called for the current execution.
  ///
  /// In the case of a missing input or command, the server SHOULD additionally
  /// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
  /// where, for each requested blob not present in the CAS, there is a
  /// `Violation` with a `type` of `MISSING` and a `subject` of
  /// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
  ///
  /// The server does not need to guarantee that a call to this method leads to
  /// at most one execution of the action. The server MAY execute the action
  /// multiple times, potentially in parallel. These redundant executions MAY
  /// continue to run, even if the operation is completed.
  func execute(request: Build_Bazel_Remote_Execution_V2_ExecuteRequest, context: StreamingResponseCallContext<Google_Longrunning_Operation>) -> EventLoopFuture<GRPCStatus>

  /// Wait for an execution operation to complete. When the client initially
  /// makes the request, the server immediately responds with the current status
  /// of the execution. The server will leave the request stream open until the
  /// operation completes, and then respond with the completed operation. The
  /// server MAY choose to stream additional updates as execution progresses,
  /// such as to provide an update as to the state of the execution.
  func waitExecution(request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, context: StreamingResponseCallContext<Google_Longrunning_Operation>) -> EventLoopFuture<GRPCStatus>
}

extension Build_Bazel_Remote_Execution_V2_ExecutionProvider {
  public var serviceName: Substring { return "build.bazel.remote.execution.v2.Execution" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "Execute":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_ExecuteRequest>(),
        responseSerializer: ProtobufSerializer<Google_Longrunning_Operation>(),
        interceptors: self.interceptors?.makeExecuteInterceptors() ?? [],
        userFunction: self.execute(request:context:)
      )

    case "WaitExecution":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest>(),
        responseSerializer: ProtobufSerializer<Google_Longrunning_Operation>(),
        interceptors: self.interceptors?.makeWaitExecutionInterceptors() ?? [],
        userFunction: self.waitExecution(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ExecutionServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'execute'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeExecuteInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation>]

  /// - Returns: Interceptors to use when handling 'waitExecution'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeWaitExecutionInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation>]
}
/// The action cache API is used to query whether a given action has already been
/// performed and, if so, retrieve its result. Unlike the
/// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage],
/// which addresses blobs by their own content, the action cache addresses the
/// [ActionResult][build.bazel.remote.execution.v2.ActionResult] by a
/// digest of the encoded [Action][build.bazel.remote.execution.v2.Action]
/// which produced them.
///
/// The lifetime of entries in the action cache is implementation-specific, but
/// the server SHOULD assume that more recently used entries are more likely to
/// be used again.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ActionCacheProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Execution_V2_ActionCacheServerInterceptorFactoryProtocol? { get }

  /// Retrieve a cached execution result.
  ///
  /// Implementations SHOULD ensure that any blobs referenced from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// are available at the time of returning the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
  /// for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
  /// if necessary and applicable.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
  func getActionResult(request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ActionResult>

  /// Upload a new execution result.
  ///
  /// In order to allow the server to perform access control based on the type of
  /// action, and to assist with client debugging, the client MUST first upload
  /// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
  /// result, along with its
  /// [Command][build.bazel.remote.execution.v2.Command], into the
  /// `ContentAddressableStorage`.
  ///
  /// Server implementations MAY modify the
  /// `UpdateActionResultRequest.action_result` and return an equivalent value.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
  ///   action result, such as a missing command or action.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
  ///   entry to the cache.
  func updateActionResult(request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ActionResult>
}

extension Build_Bazel_Remote_Execution_V2_ActionCacheProvider {
  public var serviceName: Substring { return "build.bazel.remote.execution.v2.ActionCache" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "GetActionResult":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_GetActionResultRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_ActionResult>(),
        interceptors: self.interceptors?.makeGetActionResultInterceptors() ?? [],
        userFunction: self.getActionResult(request:context:)
      )

    case "UpdateActionResult":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_ActionResult>(),
        interceptors: self.interceptors?.makeUpdateActionResultInterceptors() ?? [],
        userFunction: self.updateActionResult(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ActionCacheServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'getActionResult'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetActionResultInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>]

  /// - Returns: Interceptors to use when handling 'updateActionResult'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUpdateActionResultInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>]
}
/// The CAS (content-addressable storage) is used to store the inputs to and
/// outputs from the execution service. Each piece of content is addressed by the
/// digest of its binary data.
///
/// Most of the binary data stored in the CAS is opaque to the execution engine,
/// and is only used as a communication medium. In order to build an
/// [Action][build.bazel.remote.execution.v2.Action],
/// however, the client will need to also upload the
/// [Command][build.bazel.remote.execution.v2.Command] and input root
/// [Directory][build.bazel.remote.execution.v2.Directory] for the Action.
/// The Command and Directory messages must be marshalled to wire format and then
/// uploaded under the hash as with any other piece of content. In practice, the
/// input root directory is likely to refer to other Directories in its
/// hierarchy, which must also each be uploaded on their own.
///
/// For small file uploads the client should group them together and call
/// [BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
///
/// For large uploads, the client must use the
/// [Write method][google.bytestream.ByteStream.Write] of the ByteStream API.
///
/// For uncompressed data, The `WriteRequest.resource_name` is of the following form:
/// `{instance_name}/uploads/{uuid}/blobs/{hash}/{size}{/optional_metadata}`
///
/// Where:
/// * `instance_name` is an identifier, possibly containing multiple path
///   segments, used to distinguish between the various instances on the server,
///   in a manner defined by the server. If it is the empty path, the leading
///   slash is omitted, so that  the `resource_name` becomes
///   `uploads/{uuid}/blobs/{hash}/{size}{/optional_metadata}`.
///   To simplify parsing, a path segment cannot equal any of the following
///   keywords: `blobs`, `uploads`, `actions`, `actionResults`, `operations`,
///   `capabilities` or `compressed-blobs`.
/// * `uuid` is a version 4 UUID generated by the client, used to avoid
///   collisions between concurrent uploads of the same data. Clients MAY
///   reuse the same `uuid` for uploading different blobs.
/// * `hash` and `size` refer to the [Digest][build.bazel.remote.execution.v2.Digest]
///   of the data being uploaded.
/// * `optional_metadata` is implementation specific data, which clients MAY omit.
///   Servers MAY ignore this metadata.
///
/// Data can alternatively be uploaded in compressed form, with the following
/// `WriteRequest.resource_name` form:
/// `{instance_name}/uploads/{uuid}/compressed-blobs/{compressor}/{uncompressed_hash}/{uncompressed_size}{/optional_metadata}`
///
/// Where:
/// * `instance_name`, `uuid` and `optional_metadata` are defined as above.
/// * `compressor` is a lowercase string form of a `Compressor.Value` enum
///   other than `identity`, which is supported by the server and advertised in
///   [CacheCapabilities.supported_compressor][build.bazel.remote.execution.v2.CacheCapabilities.supported_compressor].
/// * `uncompressed_hash` and `uncompressed_size` refer to the
///   [Digest][build.bazel.remote.execution.v2.Digest] of the data being
///   uploaded, once uncompressed. Servers MUST verify that these match
///   the uploaded data once uncompressed, and MUST return an
///   `INVALID_ARGUMENT` error in the case of mismatch.
///
/// Note that when writing compressed blobs, the `WriteRequest.write_offset` in
/// the initial request in a stream refers to the offset in the uncompressed form
/// of the blob. In subsequent requests, `WriteRequest.write_offset` MUST be the
/// sum of the first request's 'WriteRequest.write_offset' and the total size of
/// all the compressed data bundles in the previous requests.
/// Note that this mixes an uncompressed offset with a compressed byte length,
/// which is nonsensical, but it is done to fit the semantics of the existing
/// ByteStream protocol.
///
/// Uploads of the same data MAY occur concurrently in any form, compressed or
/// uncompressed.
///
/// Clients SHOULD NOT use gRPC-level compression for ByteStream API `Write`
/// calls of compressed blobs, since this would compress already-compressed data.
///
/// When attempting an upload, if another client has already completed the upload
/// (which may occur in the middle of a single upload if another client uploads
/// the same blob concurrently), the request will terminate immediately with
/// a response whose `committed_size` is the full size of the uploaded file
/// (regardless of how much data was transmitted by the client). If the client
/// completes the upload but the
/// [Digest][build.bazel.remote.execution.v2.Digest] does not match, an
/// `INVALID_ARGUMENT` error will be returned. In either case, the client should
/// not attempt to retry the upload.
///
/// Small downloads can be grouped and requested in a batch via
/// [BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
///
/// For large downloads, the client must use the
/// [Read method][google.bytestream.ByteStream.Read] of the ByteStream API.
///
/// For uncompressed data, The `ReadRequest.resource_name` is of the following form:
/// `{instance_name}/blobs/{hash}/{size}`
/// Where `instance_name`, `hash` and `size` are defined as for uploads.
///
/// Data can alternatively be downloaded in compressed form, with the following
/// `ReadRequest.resource_name` form:
/// `{instance_name}/compressed-blobs/{compressor}/{uncompressed_hash}/{uncompressed_size}`
///
/// Where:
/// * `instance_name` and `compressor` are defined as for uploads.
/// * `uncompressed_hash` and `uncompressed_size` refer to the
///   [Digest][build.bazel.remote.execution.v2.Digest] of the data being
///   downloaded, once uncompressed. Clients MUST verify that these match
///   the downloaded data once uncompressed, and take appropriate steps in
///   the case of failure such as retrying a limited number of times or
///   surfacing an error to the user.
///
/// When downloading compressed blobs:
/// * `ReadRequest.read_offset` refers to the offset in the uncompressed form
///   of the blob.
/// * Servers MUST return `INVALID_ARGUMENT` if `ReadRequest.read_limit` is
///   non-zero.
/// * Servers MAY use any compression level they choose, including different
///   levels for different blobs (e.g. choosing a level designed for maximum
///   speed for data known to be incompressible).
/// * Clients SHOULD NOT use gRPC-level compression, since this would compress
///   already-compressed data.
///
/// Servers MUST be able to provide data for all recently advertised blobs in
/// each of the compression formats that the server supports, as well as in
/// uncompressed form.
///
/// The lifetime of entries in the CAS is implementation specific, but it SHOULD
/// be long enough to allow for newly-added and recently looked-up entries to be
/// used in subsequent calls (e.g. to
/// [Execute][build.bazel.remote.execution.v2.Execution.Execute]).
///
/// Servers MUST behave as though empty blobs are always available, even if they
/// have not been uploaded. Clients MAY optimize away the uploading or
/// downloading of empty blobs.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Execution_V2_ContentAddressableStorageServerInterceptorFactoryProtocol? { get }

  /// Determine if blobs are present in the CAS.
  ///
  /// Clients can use this API before uploading blobs to determine which ones are
  /// already present in the CAS and do not need to be uploaded again.
  ///
  /// Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
  /// applicable.
  ///
  /// There are no method-specific errors.
  func findMissingBlobs(request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>

  /// Upload many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be uploaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or uploaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Write` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to upload more than the
  ///   server supported limit.
  ///
  /// Individual requests may return the following errors, additionally:
  ///
  /// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
  /// * `INVALID_ARGUMENT`: The
  /// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
  /// provided data.
  func batchUpdateBlobs(request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>

  /// Download many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be downloaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or downloaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Read` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to read more than the
  ///   server supported limit.
  ///
  /// Every error on individual read will be returned in the corresponding digest
  /// status.
  func batchReadBlobs(request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>

  /// Fetch the entire directory tree rooted at a node.
  ///
  /// This request must be targeted at a
  /// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// (CAS). The server will enumerate the `Directory` tree recursively and
  /// return every node descended from the root.
  ///
  /// The GetTreeRequest.page_token parameter can be used to skip ahead in
  /// the stream (e.g. when retrying a partially completed and aborted request),
  /// by setting it to a value taken from GetTreeResponse.next_page_token of the
  /// last successfully processed GetTreeResponse).
  ///
  /// The exact traversal order is unspecified and, unless retrieving subsequent
  /// pages from an earlier request, is not guaranteed to be stable across
  /// multiple invocations of `GetTree`.
  ///
  /// If part of the tree is missing from the CAS, the server will return the
  /// portion present and omit the rest.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested tree root is not present in the CAS.
  func getTree(request: Build_Bazel_Remote_Execution_V2_GetTreeRequest, context: StreamingResponseCallContext<Build_Bazel_Remote_Execution_V2_GetTreeResponse>) -> EventLoopFuture<GRPCStatus>
}

extension Build_Bazel_Remote_Execution_V2_ContentAddressableStorageProvider {
  public var serviceName: Substring { return "build.bazel.remote.execution.v2.ContentAddressableStorage" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "FindMissingBlobs":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>(),
        interceptors: self.interceptors?.makeFindMissingBlobsInterceptors() ?? [],
        userFunction: self.findMissingBlobs(request:context:)
      )

    case "BatchUpdateBlobs":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>(),
        interceptors: self.interceptors?.makeBatchUpdateBlobsInterceptors() ?? [],
        userFunction: self.batchUpdateBlobs(request:context:)
      )

    case "BatchReadBlobs":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>(),
        interceptors: self.interceptors?.makeBatchReadBlobsInterceptors() ?? [],
        userFunction: self.batchReadBlobs(request:context:)
      )

    case "GetTree":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_GetTreeRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_GetTreeResponse>(),
        interceptors: self.interceptors?.makeGetTreeInterceptors() ?? [],
        userFunction: self.getTree(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'findMissingBlobs'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFindMissingBlobsInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>]

  /// - Returns: Interceptors to use when handling 'batchUpdateBlobs'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeBatchUpdateBlobsInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>]

  /// - Returns: Interceptors to use when handling 'batchReadBlobs'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeBatchReadBlobsInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>]

  /// - Returns: Interceptors to use when handling 'getTree'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetTreeInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse>]
}
/// The Capabilities service may be used by remote execution clients to query
/// various server properties, in order to self-configure or return meaningful
/// error messages.
///
/// The query may include a particular `instance_name`, in which case the values
/// returned will pertain to that instance.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Execution_V2_CapabilitiesServerInterceptorFactoryProtocol? { get }

  /// GetCapabilities returns the server capabilities configuration of the
  /// remote endpoint.
  /// Only the capabilities of the services supported by the endpoint will
  /// be returned:
  /// * Execution + CAS + Action Cache endpoints should return both
  ///   CacheCapabilities and ExecutionCapabilities.
  /// * Execution only endpoints should return ExecutionCapabilities.
  /// * CAS + Action Cache only endpoints should return CacheCapabilities.
  func getCapabilities(request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ServerCapabilities>
}

extension Build_Bazel_Remote_Execution_V2_CapabilitiesProvider {
  public var serviceName: Substring { return "build.bazel.remote.execution.v2.Capabilities" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "GetCapabilities":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Execution_V2_ServerCapabilities>(),
        interceptors: self.interceptors?.makeGetCapabilitiesInterceptors() ?? [],
        userFunction: self.getCapabilities(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'getCapabilities'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetCapabilitiesInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities>]
}
