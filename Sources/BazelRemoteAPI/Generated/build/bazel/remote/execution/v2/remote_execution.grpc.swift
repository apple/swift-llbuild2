//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: build/bazel/remote/execution/v2/remote_execution.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import Foundation
import GRPC
import NIO
import NIOHTTP1
import SwiftProtobuf


/// Usage: instantiate Build_Bazel_Remote_Execution_V2_ExecutionClient, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ExecutionClientProtocol {
  func execute(_ request: Build_Bazel_Remote_Execution_V2_ExecuteRequest, callOptions: CallOptions?, handler: @escaping (Google_Longrunning_Operation) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation>
  func waitExecution(_ request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, callOptions: CallOptions?, handler: @escaping (Google_Longrunning_Operation) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation>
}

public final class Build_Bazel_Remote_Execution_V2_ExecutionClient: GRPCClient, Build_Bazel_Remote_Execution_V2_ExecutionClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions

  /// Creates a client for the build.bazel.remote.execution.v2.Execution service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  public init(channel: GRPCChannel, defaultCallOptions: CallOptions = CallOptions()) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
  }

  /// Execute an action remotely.
  ///
  /// In order to execute an action, the client must first upload all of the
  /// inputs, the
  /// [Command][build.bazel.remote.execution.v2.Command] to run, and the
  /// [Action][build.bazel.remote.execution.v2.Action] into the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  /// It then calls `Execute` with an `action_digest` referring to them. The
  /// server will run the action and eventually return the result.
  ///
  /// The input `Action`'s fields MUST meet the various canonicalization
  /// requirements specified in the documentation for their types so that it has
  /// the same digest as other logically equivalent `Action`s. The server MAY
  /// enforce the requirements and return errors if a non-canonical input is
  /// received. It MAY also proceed without verifying some or all of the
  /// requirements, such as for performance reasons. If the server does not
  /// verify the requirement, then it will treat the `Action` as distinct from
  /// another logically equivalent action if they hash differently.
  ///
  /// Returns a stream of
  /// [google.longrunning.Operation][google.longrunning.Operation] messages
  /// describing the resulting execution, with eventual `response`
  /// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
  /// `metadata` on the operation is of type
  /// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
  ///
  /// If the client remains connected after the first response is returned after
  /// the server, then updates are streamed as if the client had called
  /// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
  /// until the execution completes or the request reaches an error. The
  /// operation can also be queried using [Operations
  /// API][google.longrunning.Operations.GetOperation].
  ///
  /// The server NEED NOT implement other methods or functionality of the
  /// Operations API.
  ///
  /// Errors discovered during creation of the `Operation` will be reported
  /// as gRPC Status errors, while errors that occurred while running the
  /// action will be reported in the `status` field of the `ExecuteResponse`. The
  /// server MUST NOT set the `error` field of the `Operation` proto.
  /// The possible errors include:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
  ///   action requested, such as a missing input or command or no worker being
  ///   available. The client may be able to fix the errors and retry.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
  ///   the action.
  /// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
  ///   occupied (and the server does not support a queue), the action could not
  ///   be started. The client should retry.
  /// * `INTERNAL`: An internal error occurred in the execution engine or the
  ///   worker.
  /// * `DEADLINE_EXCEEDED`: The execution timed out.
  /// * `CANCELLED`: The operation was cancelled by the client. This status is
  ///   only possible if the server implements the Operations API CancelOperation
  ///   method, and it was called for the current execution.
  ///
  /// In the case of a missing input or command, the server SHOULD additionally
  /// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
  /// where, for each requested blob not present in the CAS, there is a
  /// `Violation` with a `type` of `MISSING` and a `subject` of
  /// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
  ///
  /// - Parameters:
  ///   - request: Request to send to Execute.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func execute(_ request: Build_Bazel_Remote_Execution_V2_ExecuteRequest, callOptions: CallOptions? = nil, handler: @escaping (Google_Longrunning_Operation) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_ExecuteRequest, Google_Longrunning_Operation> {
    return self.makeServerStreamingCall(path: "/build.bazel.remote.execution.v2.Execution/Execute",
                                        request: request,
                                        callOptions: callOptions ?? self.defaultCallOptions,
                                        handler: handler)
  }

  /// Wait for an execution operation to complete. When the client initially
  /// makes the request, the server immediately responds with the current status
  /// of the execution. The server will leave the request stream open until the
  /// operation completes, and then respond with the completed operation. The
  /// server MAY choose to stream additional updates as execution progresses,
  /// such as to provide an update as to the state of the execution.
  ///
  /// - Parameters:
  ///   - request: Request to send to WaitExecution.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func waitExecution(_ request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, callOptions: CallOptions? = nil, handler: @escaping (Google_Longrunning_Operation) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, Google_Longrunning_Operation> {
    return self.makeServerStreamingCall(path: "/build.bazel.remote.execution.v2.Execution/WaitExecution",
                                        request: request,
                                        callOptions: callOptions ?? self.defaultCallOptions,
                                        handler: handler)
  }

}

/// Usage: instantiate Build_Bazel_Remote_Execution_V2_ActionCacheClient, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ActionCacheClientProtocol {
  func getActionResult(_ request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>
  func updateActionResult(_ request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult>
}

public final class Build_Bazel_Remote_Execution_V2_ActionCacheClient: GRPCClient, Build_Bazel_Remote_Execution_V2_ActionCacheClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions

  /// Creates a client for the build.bazel.remote.execution.v2.ActionCache service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  public init(channel: GRPCChannel, defaultCallOptions: CallOptions = CallOptions()) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
  }

  /// Retrieve a cached execution result.
  ///
  /// Implementations SHOULD ensure that any blobs referenced from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// are available at the time of returning the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
  /// for some period of time afterwards. The TTLs of the referenced blobs SHOULD be increased
  /// if necessary and applicable.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetActionResult.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getActionResult(_ request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.ActionCache/GetActionResult",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

  /// Upload a new execution result.
  ///
  /// In order to allow the server to perform access control based on the type of
  /// action, and to assist with client debugging, the client MUST first upload
  /// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
  /// result, along with its
  /// [Command][build.bazel.remote.execution.v2.Command], into the
  /// `ContentAddressableStorage`.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
  ///   action result, such as a missing command or action.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
  ///   entry to the cache.
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateActionResult.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateActionResult(_ request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, Build_Bazel_Remote_Execution_V2_ActionResult> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.ActionCache/UpdateActionResult",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

}

/// Usage: instantiate Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClient, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientProtocol {
  func findMissingBlobs(_ request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>
  func batchUpdateBlobs(_ request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>
  func batchReadBlobs(_ request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>
  func getTree(_ request: Build_Bazel_Remote_Execution_V2_GetTreeRequest, callOptions: CallOptions?, handler: @escaping (Build_Bazel_Remote_Execution_V2_GetTreeResponse) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse>
}

public final class Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClient: GRPCClient, Build_Bazel_Remote_Execution_V2_ContentAddressableStorageClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions

  /// Creates a client for the build.bazel.remote.execution.v2.ContentAddressableStorage service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  public init(channel: GRPCChannel, defaultCallOptions: CallOptions = CallOptions()) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
  }

  /// Determine if blobs are present in the CAS.
  ///
  /// Clients can use this API before uploading blobs to determine which ones are
  /// already present in the CAS and do not need to be uploaded again.
  ///
  /// Servers SHOULD increase the TTLs of the referenced blobs if necessary and
  /// applicable.
  ///
  /// There are no method-specific errors.
  ///
  /// - Parameters:
  ///   - request: Request to send to FindMissingBlobs.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func findMissingBlobs(_ request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/FindMissingBlobs",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

  /// Upload many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be uploaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or uploaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Write` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to upload more than the
  ///   server supported limit.
  ///
  /// Individual requests may return the following errors, additionally:
  ///
  /// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
  /// * `INVALID_ARGUMENT`: The
  /// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
  /// provided data.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchUpdateBlobs.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchUpdateBlobs(_ request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchUpdateBlobs",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

  /// Download many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be downloaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or downloaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Read` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to read more than the
  ///   server supported limit.
  ///
  /// Every error on individual read will be returned in the corresponding digest
  /// status.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchReadBlobs.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchReadBlobs(_ request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchReadBlobs",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

  /// Fetch the entire directory tree rooted at a node.
  ///
  /// This request must be targeted at a
  /// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// (CAS). The server will enumerate the `Directory` tree recursively and
  /// return every node descended from the root.
  ///
  /// The GetTreeRequest.page_token parameter can be used to skip ahead in
  /// the stream (e.g. when retrying a partially completed and aborted request),
  /// by setting it to a value taken from GetTreeResponse.next_page_token of the
  /// last successfully processed GetTreeResponse).
  ///
  /// The exact traversal order is unspecified and, unless retrieving subsequent
  /// pages from an earlier request, is not guaranteed to be stable across
  /// multiple invocations of `GetTree`.
  ///
  /// If part of the tree is missing from the CAS, the server will return the
  /// portion present and omit the rest.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested tree root is not present in the CAS.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetTree.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func getTree(_ request: Build_Bazel_Remote_Execution_V2_GetTreeRequest, callOptions: CallOptions? = nil, handler: @escaping (Build_Bazel_Remote_Execution_V2_GetTreeResponse) -> Void) -> ServerStreamingCall<Build_Bazel_Remote_Execution_V2_GetTreeRequest, Build_Bazel_Remote_Execution_V2_GetTreeResponse> {
    return self.makeServerStreamingCall(path: "/build.bazel.remote.execution.v2.ContentAddressableStorage/GetTree",
                                        request: request,
                                        callOptions: callOptions ?? self.defaultCallOptions,
                                        handler: handler)
  }

}

/// Usage: instantiate Build_Bazel_Remote_Execution_V2_CapabilitiesClient, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesClientProtocol {
  func getCapabilities(_ request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, callOptions: CallOptions?) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities>
}

public final class Build_Bazel_Remote_Execution_V2_CapabilitiesClient: GRPCClient, Build_Bazel_Remote_Execution_V2_CapabilitiesClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions

  /// Creates a client for the build.bazel.remote.execution.v2.Capabilities service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  public init(channel: GRPCChannel, defaultCallOptions: CallOptions = CallOptions()) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
  }

  /// GetCapabilities returns the server capabilities configuration of the
  /// remote endpoint.
  /// Only the capabilities of the services supported by the endpoint will
  /// be returned:
  /// * Execution + CAS + Action Cache endpoints should return both
  ///   CacheCapabilities and ExecutionCapabilities.
  /// * Execution only endpoints should return ExecutionCapabilities.
  /// * CAS + Action Cache only endpoints should return CacheCapabilities.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetCapabilities.
  ///   - callOptions: Call options; `self.defaultCallOptions` is used if `nil`.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getCapabilities(_ request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, callOptions: CallOptions? = nil) -> UnaryCall<Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, Build_Bazel_Remote_Execution_V2_ServerCapabilities> {
    return self.makeUnaryCall(path: "/build.bazel.remote.execution.v2.Capabilities/GetCapabilities",
                              request: request,
                              callOptions: callOptions ?? self.defaultCallOptions)
  }

}

/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ExecutionProvider: CallHandlerProvider {
  /// Execute an action remotely.
  ///
  /// In order to execute an action, the client must first upload all of the
  /// inputs, the
  /// [Command][build.bazel.remote.execution.v2.Command] to run, and the
  /// [Action][build.bazel.remote.execution.v2.Action] into the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  /// It then calls `Execute` with an `action_digest` referring to them. The
  /// server will run the action and eventually return the result.
  ///
  /// The input `Action`'s fields MUST meet the various canonicalization
  /// requirements specified in the documentation for their types so that it has
  /// the same digest as other logically equivalent `Action`s. The server MAY
  /// enforce the requirements and return errors if a non-canonical input is
  /// received. It MAY also proceed without verifying some or all of the
  /// requirements, such as for performance reasons. If the server does not
  /// verify the requirement, then it will treat the `Action` as distinct from
  /// another logically equivalent action if they hash differently.
  ///
  /// Returns a stream of
  /// [google.longrunning.Operation][google.longrunning.Operation] messages
  /// describing the resulting execution, with eventual `response`
  /// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
  /// `metadata` on the operation is of type
  /// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
  ///
  /// If the client remains connected after the first response is returned after
  /// the server, then updates are streamed as if the client had called
  /// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
  /// until the execution completes or the request reaches an error. The
  /// operation can also be queried using [Operations
  /// API][google.longrunning.Operations.GetOperation].
  ///
  /// The server NEED NOT implement other methods or functionality of the
  /// Operations API.
  ///
  /// Errors discovered during creation of the `Operation` will be reported
  /// as gRPC Status errors, while errors that occurred while running the
  /// action will be reported in the `status` field of the `ExecuteResponse`. The
  /// server MUST NOT set the `error` field of the `Operation` proto.
  /// The possible errors include:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
  ///   action requested, such as a missing input or command or no worker being
  ///   available. The client may be able to fix the errors and retry.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
  ///   the action.
  /// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
  ///   occupied (and the server does not support a queue), the action could not
  ///   be started. The client should retry.
  /// * `INTERNAL`: An internal error occurred in the execution engine or the
  ///   worker.
  /// * `DEADLINE_EXCEEDED`: The execution timed out.
  /// * `CANCELLED`: The operation was cancelled by the client. This status is
  ///   only possible if the server implements the Operations API CancelOperation
  ///   method, and it was called for the current execution.
  ///
  /// In the case of a missing input or command, the server SHOULD additionally
  /// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
  /// where, for each requested blob not present in the CAS, there is a
  /// `Violation` with a `type` of `MISSING` and a `subject` of
  /// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
  func execute(request: Build_Bazel_Remote_Execution_V2_ExecuteRequest, context: StreamingResponseCallContext<Google_Longrunning_Operation>) -> EventLoopFuture<GRPCStatus>
  /// Wait for an execution operation to complete. When the client initially
  /// makes the request, the server immediately responds with the current status
  /// of the execution. The server will leave the request stream open until the
  /// operation completes, and then respond with the completed operation. The
  /// server MAY choose to stream additional updates as execution progresses,
  /// such as to provide an update as to the state of the execution.
  func waitExecution(request: Build_Bazel_Remote_Execution_V2_WaitExecutionRequest, context: StreamingResponseCallContext<Google_Longrunning_Operation>) -> EventLoopFuture<GRPCStatus>
}

extension Build_Bazel_Remote_Execution_V2_ExecutionProvider {
  public var serviceName: String { return "build.bazel.remote.execution.v2.Execution" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handleMethod(_ methodName: String, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
    switch methodName {
    case "Execute":
      return ServerStreamingCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.execute(request: request, context: context)
        }
      }

    case "WaitExecution":
      return ServerStreamingCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.waitExecution(request: request, context: context)
        }
      }

    default: return nil
    }
  }
}

/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ActionCacheProvider: CallHandlerProvider {
  /// Retrieve a cached execution result.
  ///
  /// Implementations SHOULD ensure that any blobs referenced from the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// are available at the time of returning the
  /// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
  /// for some period of time afterwards. The TTLs of the referenced blobs SHOULD be increased
  /// if necessary and applicable.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
  func getActionResult(request: Build_Bazel_Remote_Execution_V2_GetActionResultRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ActionResult>
  /// Upload a new execution result.
  ///
  /// In order to allow the server to perform access control based on the type of
  /// action, and to assist with client debugging, the client MUST first upload
  /// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
  /// result, along with its
  /// [Command][build.bazel.remote.execution.v2.Command], into the
  /// `ContentAddressableStorage`.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: One or more arguments are invalid.
  /// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
  ///   action result, such as a missing command or action.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
  ///   entry to the cache.
  func updateActionResult(request: Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ActionResult>
}

extension Build_Bazel_Remote_Execution_V2_ActionCacheProvider {
  public var serviceName: String { return "build.bazel.remote.execution.v2.ActionCache" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handleMethod(_ methodName: String, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
    switch methodName {
    case "GetActionResult":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.getActionResult(request: request, context: context)
        }
      }

    case "UpdateActionResult":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.updateActionResult(request: request, context: context)
        }
      }

    default: return nil
    }
  }
}

/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_ContentAddressableStorageProvider: CallHandlerProvider {
  /// Determine if blobs are present in the CAS.
  ///
  /// Clients can use this API before uploading blobs to determine which ones are
  /// already present in the CAS and do not need to be uploaded again.
  ///
  /// Servers SHOULD increase the TTLs of the referenced blobs if necessary and
  /// applicable.
  ///
  /// There are no method-specific errors.
  func findMissingBlobs(request: Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse>
  /// Upload many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be uploaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or uploaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Write` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to upload more than the
  ///   server supported limit.
  ///
  /// Individual requests may return the following errors, additionally:
  ///
  /// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
  /// * `INVALID_ARGUMENT`: The
  /// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
  /// provided data.
  func batchUpdateBlobs(request: Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse>
  /// Download many blobs at once.
  ///
  /// The server may enforce a limit of the combined total size of blobs
  /// to be downloaded using this API. This limit may be obtained using the
  /// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
  /// Requests exceeding the limit should either be split into smaller
  /// chunks or downloaded using the
  /// [ByteStream API][google.bytestream.ByteStream], as appropriate.
  ///
  /// This request is equivalent to calling a Bytestream `Read` request
  /// on each individual blob, in parallel. The requests may succeed or fail
  /// independently.
  ///
  /// Errors:
  ///
  /// * `INVALID_ARGUMENT`: The client attempted to read more than the
  ///   server supported limit.
  ///
  /// Every error on individual read will be returned in the corresponding digest
  /// status.
  func batchReadBlobs(request: Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse>
  /// Fetch the entire directory tree rooted at a node.
  ///
  /// This request must be targeted at a
  /// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
  /// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  /// (CAS). The server will enumerate the `Directory` tree recursively and
  /// return every node descended from the root.
  ///
  /// The GetTreeRequest.page_token parameter can be used to skip ahead in
  /// the stream (e.g. when retrying a partially completed and aborted request),
  /// by setting it to a value taken from GetTreeResponse.next_page_token of the
  /// last successfully processed GetTreeResponse).
  ///
  /// The exact traversal order is unspecified and, unless retrieving subsequent
  /// pages from an earlier request, is not guaranteed to be stable across
  /// multiple invocations of `GetTree`.
  ///
  /// If part of the tree is missing from the CAS, the server will return the
  /// portion present and omit the rest.
  ///
  /// Errors:
  ///
  /// * `NOT_FOUND`: The requested tree root is not present in the CAS.
  func getTree(request: Build_Bazel_Remote_Execution_V2_GetTreeRequest, context: StreamingResponseCallContext<Build_Bazel_Remote_Execution_V2_GetTreeResponse>) -> EventLoopFuture<GRPCStatus>
}

extension Build_Bazel_Remote_Execution_V2_ContentAddressableStorageProvider {
  public var serviceName: String { return "build.bazel.remote.execution.v2.ContentAddressableStorage" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handleMethod(_ methodName: String, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
    switch methodName {
    case "FindMissingBlobs":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.findMissingBlobs(request: request, context: context)
        }
      }

    case "BatchUpdateBlobs":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.batchUpdateBlobs(request: request, context: context)
        }
      }

    case "BatchReadBlobs":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.batchReadBlobs(request: request, context: context)
        }
      }

    case "GetTree":
      return ServerStreamingCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.getTree(request: request, context: context)
        }
      }

    default: return nil
    }
  }
}

/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Execution_V2_CapabilitiesProvider: CallHandlerProvider {
  /// GetCapabilities returns the server capabilities configuration of the
  /// remote endpoint.
  /// Only the capabilities of the services supported by the endpoint will
  /// be returned:
  /// * Execution + CAS + Action Cache endpoints should return both
  ///   CacheCapabilities and ExecutionCapabilities.
  /// * Execution only endpoints should return ExecutionCapabilities.
  /// * CAS + Action Cache only endpoints should return CacheCapabilities.
  func getCapabilities(request: Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Execution_V2_ServerCapabilities>
}

extension Build_Bazel_Remote_Execution_V2_CapabilitiesProvider {
  public var serviceName: String { return "build.bazel.remote.execution.v2.Capabilities" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handleMethod(_ methodName: String, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
    switch methodName {
    case "GetCapabilities":
      return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.getCapabilities(request: request, context: context)
        }
      }

    default: return nil
    }
  }
}


// Provides conformance to `GRPCPayload`
extension Build_Bazel_Remote_Execution_V2_Action: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_Command: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_Platform: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_Directory: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_NodeProperty: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_NodeProperties: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_FileNode: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_DirectoryNode: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_SymlinkNode: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_Digest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecutedActionMetadata: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ActionResult: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_OutputFile: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_Tree: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_OutputDirectory: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_OutputSymlink: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecutionPolicy: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ResultsCachePolicy: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecuteRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_LogFile: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecuteResponse: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecutionStage: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecuteOperationMetadata: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_WaitExecutionRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_GetActionResultRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_UpdateActionResultRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_FindMissingBlobsRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_FindMissingBlobsResponse: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_BatchUpdateBlobsResponse: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_BatchReadBlobsRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_BatchReadBlobsResponse: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_GetTreeRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_GetTreeResponse: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_GetCapabilitiesRequest: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ServerCapabilities: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_DigestFunction: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ActionCacheUpdateCapabilities: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_PriorityCapabilities: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_SymlinkAbsolutePathStrategy: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_CacheCapabilities: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ExecutionCapabilities: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_ToolDetails: GRPCProtobufPayload {}
extension Build_Bazel_Remote_Execution_V2_RequestMetadata: GRPCProtobufPayload {}
