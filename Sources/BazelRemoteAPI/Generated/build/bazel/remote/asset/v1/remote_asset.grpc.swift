//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: build/bazel/remote/asset/v1/remote_asset.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


/// The Fetch service resolves or fetches assets referenced by URI and
/// Qualifiers, returning a Digest for the content in 
/// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// Usage: instantiate `Build_Bazel_Remote_Asset_V1_FetchClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Asset_V1_FetchClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Asset_V1_FetchClientInterceptorFactoryProtocol? { get }

  func fetchBlob(
    _ request: Build_Bazel_Remote_Asset_V1_FetchBlobRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_FetchBlobRequest, Build_Bazel_Remote_Asset_V1_FetchBlobResponse>

  func fetchDirectory(
    _ request: Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse>
}

extension Build_Bazel_Remote_Asset_V1_FetchClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.asset.v1.Fetch"
  }

  /// Resolve or fetch referenced assets, making them available to the caller and
  /// other consumers in the [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  ///
  /// Servers *MAY* fetch content that they do not already have cached, for any
  /// URLs they support.
  ///
  /// Servers *SHOULD* ensure that referenced files are present in the CAS at the
  /// time of the response, and (if supported) that they will remain available
  /// for a reasonable period of time. The lifetimes of the referenced blobs *SHOULD*
  /// be increased if necessary and applicable.
  /// In the event that a client receives a reference to content that is no
  /// longer present, it *MAY* re-issue the request with
  /// `oldest_content_accepted` set to a more recent timestamp than the original
  /// attempt, to induce a re-fetch from origin.
  ///
  /// Servers *MAY* cache fetched content and reuse it for subsequent requests,
  /// subject to `oldest_content_accepted`.
  ///
  /// Servers *MAY* support the complementary [Push][build.bazel.remote.asset.v1.Push]
  /// API and allow content to be directly inserted for use in future fetch
  /// responses.
  ///
  /// Servers *MUST* ensure Fetch'd content matches all the specified
  /// qualifiers except in the case of previously Push'd resources, for which
  /// the server *MAY* trust the pushing client to have set the qualifiers
  /// correctly, without validation.
  ///
  /// Servers not implementing the complementary [Push][build.bazel.remote.asset.v1.Push]
  /// API *MUST* reject requests containing qualifiers it does not support.
  ///
  /// Servers *MAY* transform assets as part of the fetch. For example a
  /// tarball fetched by [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory]
  /// might be unpacked, or a Git repository
  /// fetched by [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob]
  /// might be passed through `git-archive`.
  ///
  /// Errors handling the requested assets will be returned as gRPC Status errors
  /// here; errors outside the server's control will be returned inline in the
  /// `status` field of the response (see comment there for details).
  /// The possible RPC errors include:
  /// * `INVALID_ARGUMENT`: One or more arguments were invalid, such as a
  ///   qualifier that is not supported by the server.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
  ///   perform the requested operation. The client may retry after a delay.
  /// * `UNAVAILABLE`: Due to a transient condition the operation could not be
  ///   completed. The client should retry.
  /// * `INTERNAL`: An internal error occurred while performing the operation.
  ///   The client should retry.
  /// * `DEADLINE_EXCEEDED`: The fetch could not be completed within the given
  ///   RPC deadline. The client should retry for at least as long as the value
  ///   provided in `timeout` field of the request.
  ///
  /// In the case of unsupported qualifiers, the server *SHOULD* additionally
  /// send a [BadRequest][google.rpc.BadRequest] error detail where, for each
  /// unsupported qualifier, there is a `FieldViolation` with a `field` of
  /// `qualifiers.name` and a `description` of `"{qualifier}" not supported`
  /// indicating the name of the unsupported qualifier.
  ///
  /// - Parameters:
  ///   - request: Request to send to FetchBlob.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func fetchBlob(
    _ request: Build_Bazel_Remote_Asset_V1_FetchBlobRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_FetchBlobRequest, Build_Bazel_Remote_Asset_V1_FetchBlobResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.asset.v1.Fetch/FetchBlob",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFetchBlobInterceptors() ?? []
    )
  }

  /// Unary call to FetchDirectory
  ///
  /// - Parameters:
  ///   - request: Request to send to FetchDirectory.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func fetchDirectory(
    _ request: Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.asset.v1.Fetch/FetchDirectory",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFetchDirectoryInterceptors() ?? []
    )
  }
}

public protocol Build_Bazel_Remote_Asset_V1_FetchClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'fetchBlob'.
  func makeFetchBlobInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Asset_V1_FetchBlobRequest, Build_Bazel_Remote_Asset_V1_FetchBlobResponse>]

  /// - Returns: Interceptors to use when invoking 'fetchDirectory'.
  func makeFetchDirectoryInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse>]
}

public final class Build_Bazel_Remote_Asset_V1_FetchClient: Build_Bazel_Remote_Asset_V1_FetchClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Asset_V1_FetchClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.asset.v1.Fetch service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Asset_V1_FetchClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The Push service is complementary to the Fetch, and allows for
/// associating contents of URLs to be returned in future Fetch API calls.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// Usage: instantiate `Build_Bazel_Remote_Asset_V1_PushClient`, then call methods of this protocol to make API calls.
public protocol Build_Bazel_Remote_Asset_V1_PushClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Build_Bazel_Remote_Asset_V1_PushClientInterceptorFactoryProtocol? { get }

  func pushBlob(
    _ request: Build_Bazel_Remote_Asset_V1_PushBlobRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_PushBlobRequest, Build_Bazel_Remote_Asset_V1_PushBlobResponse>

  func pushDirectory(
    _ request: Build_Bazel_Remote_Asset_V1_PushDirectoryRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, Build_Bazel_Remote_Asset_V1_PushDirectoryResponse>
}

extension Build_Bazel_Remote_Asset_V1_PushClientProtocol {
  public var serviceName: String {
    return "build.bazel.remote.asset.v1.Push"
  }

  /// These APIs associate the identifying information of a resource, as
  /// indicated by URI and optionally Qualifiers, with content available in the
  /// CAS. For example, associating a repository url and a commit id with a
  /// Directory Digest.
  ///
  /// Servers *SHOULD* only allow trusted clients to associate content, and *MAY*
  /// only allow certain URIs to be pushed.
  ///
  /// Clients *MUST* ensure associated content is available in CAS prior to
  /// pushing.
  ///
  /// Clients *MUST* ensure the Qualifiers listed correctly match the contents,
  /// and Servers *MAY* trust these values without validation.
  /// Fetch servers *MAY* require exact match of all qualifiers when returning
  /// content previously pushed, or allow fetching content with only a subset of
  /// the qualifiers specified on Push.
  ///
  /// Clients can specify expiration information that the server *SHOULD*
  /// respect. Subsequent requests can be used to alter the expiration time.
  ///
  /// A minimal compliant Fetch implementation may support only Push'd content
  /// and return `NOT_FOUND` for any resource that was not pushed first.
  /// Alternatively, a compliant implementation may choose to not support Push
  /// and only return resources that can be Fetch'd from origin.
  ///
  /// Errors will be returned as gRPC Status errors.
  /// The possible RPC errors include:
  /// * `INVALID_ARGUMENT`: One or more arguments to the RPC were invalid.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
  ///   perform the requested operation. The client may retry after a delay.
  /// * `UNAVAILABLE`: Due to a transient condition the operation could not be
  ///   completed. The client should retry.
  /// * `INTERNAL`: An internal error occurred while performing the operation.
  ///   The client should retry.
  ///
  /// - Parameters:
  ///   - request: Request to send to PushBlob.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func pushBlob(
    _ request: Build_Bazel_Remote_Asset_V1_PushBlobRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_PushBlobRequest, Build_Bazel_Remote_Asset_V1_PushBlobResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.asset.v1.Push/PushBlob",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePushBlobInterceptors() ?? []
    )
  }

  /// Unary call to PushDirectory
  ///
  /// - Parameters:
  ///   - request: Request to send to PushDirectory.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func pushDirectory(
    _ request: Build_Bazel_Remote_Asset_V1_PushDirectoryRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, Build_Bazel_Remote_Asset_V1_PushDirectoryResponse> {
    return self.makeUnaryCall(
      path: "/build.bazel.remote.asset.v1.Push/PushDirectory",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePushDirectoryInterceptors() ?? []
    )
  }
}

public protocol Build_Bazel_Remote_Asset_V1_PushClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'pushBlob'.
  func makePushBlobInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Asset_V1_PushBlobRequest, Build_Bazel_Remote_Asset_V1_PushBlobResponse>]

  /// - Returns: Interceptors to use when invoking 'pushDirectory'.
  func makePushDirectoryInterceptors() -> [ClientInterceptor<Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, Build_Bazel_Remote_Asset_V1_PushDirectoryResponse>]
}

public final class Build_Bazel_Remote_Asset_V1_PushClient: Build_Bazel_Remote_Asset_V1_PushClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Build_Bazel_Remote_Asset_V1_PushClientInterceptorFactoryProtocol?

  /// Creates a client for the build.bazel.remote.asset.v1.Push service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Build_Bazel_Remote_Asset_V1_PushClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The Fetch service resolves or fetches assets referenced by URI and
/// Qualifiers, returning a Digest for the content in 
/// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Asset_V1_FetchProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Asset_V1_FetchServerInterceptorFactoryProtocol? { get }

  /// Resolve or fetch referenced assets, making them available to the caller and
  /// other consumers in the [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
  ///
  /// Servers *MAY* fetch content that they do not already have cached, for any
  /// URLs they support.
  ///
  /// Servers *SHOULD* ensure that referenced files are present in the CAS at the
  /// time of the response, and (if supported) that they will remain available
  /// for a reasonable period of time. The lifetimes of the referenced blobs *SHOULD*
  /// be increased if necessary and applicable.
  /// In the event that a client receives a reference to content that is no
  /// longer present, it *MAY* re-issue the request with
  /// `oldest_content_accepted` set to a more recent timestamp than the original
  /// attempt, to induce a re-fetch from origin.
  ///
  /// Servers *MAY* cache fetched content and reuse it for subsequent requests,
  /// subject to `oldest_content_accepted`.
  ///
  /// Servers *MAY* support the complementary [Push][build.bazel.remote.asset.v1.Push]
  /// API and allow content to be directly inserted for use in future fetch
  /// responses.
  ///
  /// Servers *MUST* ensure Fetch'd content matches all the specified
  /// qualifiers except in the case of previously Push'd resources, for which
  /// the server *MAY* trust the pushing client to have set the qualifiers
  /// correctly, without validation.
  ///
  /// Servers not implementing the complementary [Push][build.bazel.remote.asset.v1.Push]
  /// API *MUST* reject requests containing qualifiers it does not support.
  ///
  /// Servers *MAY* transform assets as part of the fetch. For example a
  /// tarball fetched by [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory]
  /// might be unpacked, or a Git repository
  /// fetched by [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob]
  /// might be passed through `git-archive`.
  ///
  /// Errors handling the requested assets will be returned as gRPC Status errors
  /// here; errors outside the server's control will be returned inline in the
  /// `status` field of the response (see comment there for details).
  /// The possible RPC errors include:
  /// * `INVALID_ARGUMENT`: One or more arguments were invalid, such as a
  ///   qualifier that is not supported by the server.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
  ///   perform the requested operation. The client may retry after a delay.
  /// * `UNAVAILABLE`: Due to a transient condition the operation could not be
  ///   completed. The client should retry.
  /// * `INTERNAL`: An internal error occurred while performing the operation.
  ///   The client should retry.
  /// * `DEADLINE_EXCEEDED`: The fetch could not be completed within the given
  ///   RPC deadline. The client should retry for at least as long as the value
  ///   provided in `timeout` field of the request.
  ///
  /// In the case of unsupported qualifiers, the server *SHOULD* additionally
  /// send a [BadRequest][google.rpc.BadRequest] error detail where, for each
  /// unsupported qualifier, there is a `FieldViolation` with a `field` of
  /// `qualifiers.name` and a `description` of `"{qualifier}" not supported`
  /// indicating the name of the unsupported qualifier.
  func fetchBlob(request: Build_Bazel_Remote_Asset_V1_FetchBlobRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Asset_V1_FetchBlobResponse>

  func fetchDirectory(request: Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse>
}

extension Build_Bazel_Remote_Asset_V1_FetchProvider {
  public var serviceName: Substring { return "build.bazel.remote.asset.v1.Fetch" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "FetchBlob":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Asset_V1_FetchBlobRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Asset_V1_FetchBlobResponse>(),
        interceptors: self.interceptors?.makeFetchBlobInterceptors() ?? [],
        userFunction: self.fetchBlob(request:context:)
      )

    case "FetchDirectory":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse>(),
        interceptors: self.interceptors?.makeFetchDirectoryInterceptors() ?? [],
        userFunction: self.fetchDirectory(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Asset_V1_FetchServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'fetchBlob'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFetchBlobInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Asset_V1_FetchBlobRequest, Build_Bazel_Remote_Asset_V1_FetchBlobResponse>]

  /// - Returns: Interceptors to use when handling 'fetchDirectory'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFetchDirectoryInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse>]
}
/// The Push service is complementary to the Fetch, and allows for
/// associating contents of URLs to be returned in future Fetch API calls.
///
/// As with other services in the Remote Execution API, any call may return an
/// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
/// information about when the client should retry the request; clients SHOULD
/// respect the information provided.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Build_Bazel_Remote_Asset_V1_PushProvider: CallHandlerProvider {
  var interceptors: Build_Bazel_Remote_Asset_V1_PushServerInterceptorFactoryProtocol? { get }

  /// These APIs associate the identifying information of a resource, as
  /// indicated by URI and optionally Qualifiers, with content available in the
  /// CAS. For example, associating a repository url and a commit id with a
  /// Directory Digest.
  ///
  /// Servers *SHOULD* only allow trusted clients to associate content, and *MAY*
  /// only allow certain URIs to be pushed.
  ///
  /// Clients *MUST* ensure associated content is available in CAS prior to
  /// pushing.
  ///
  /// Clients *MUST* ensure the Qualifiers listed correctly match the contents,
  /// and Servers *MAY* trust these values without validation.
  /// Fetch servers *MAY* require exact match of all qualifiers when returning
  /// content previously pushed, or allow fetching content with only a subset of
  /// the qualifiers specified on Push.
  ///
  /// Clients can specify expiration information that the server *SHOULD*
  /// respect. Subsequent requests can be used to alter the expiration time.
  ///
  /// A minimal compliant Fetch implementation may support only Push'd content
  /// and return `NOT_FOUND` for any resource that was not pushed first.
  /// Alternatively, a compliant implementation may choose to not support Push
  /// and only return resources that can be Fetch'd from origin.
  ///
  /// Errors will be returned as gRPC Status errors.
  /// The possible RPC errors include:
  /// * `INVALID_ARGUMENT`: One or more arguments to the RPC were invalid.
  /// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
  ///   perform the requested operation. The client may retry after a delay.
  /// * `UNAVAILABLE`: Due to a transient condition the operation could not be
  ///   completed. The client should retry.
  /// * `INTERNAL`: An internal error occurred while performing the operation.
  ///   The client should retry.
  func pushBlob(request: Build_Bazel_Remote_Asset_V1_PushBlobRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Asset_V1_PushBlobResponse>

  func pushDirectory(request: Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Build_Bazel_Remote_Asset_V1_PushDirectoryResponse>
}

extension Build_Bazel_Remote_Asset_V1_PushProvider {
  public var serviceName: Substring { return "build.bazel.remote.asset.v1.Push" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "PushBlob":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Asset_V1_PushBlobRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Asset_V1_PushBlobResponse>(),
        interceptors: self.interceptors?.makePushBlobInterceptors() ?? [],
        userFunction: self.pushBlob(request:context:)
      )

    case "PushDirectory":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Build_Bazel_Remote_Asset_V1_PushDirectoryRequest>(),
        responseSerializer: ProtobufSerializer<Build_Bazel_Remote_Asset_V1_PushDirectoryResponse>(),
        interceptors: self.interceptors?.makePushDirectoryInterceptors() ?? [],
        userFunction: self.pushDirectory(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol Build_Bazel_Remote_Asset_V1_PushServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'pushBlob'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makePushBlobInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Asset_V1_PushBlobRequest, Build_Bazel_Remote_Asset_V1_PushBlobResponse>]

  /// - Returns: Interceptors to use when handling 'pushDirectory'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makePushDirectoryInterceptors() -> [ServerInterceptor<Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, Build_Bazel_Remote_Asset_V1_PushDirectoryResponse>]
}
