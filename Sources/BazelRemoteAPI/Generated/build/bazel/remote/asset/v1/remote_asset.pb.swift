// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: build/bazel/remote/asset/v1/remote_asset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 The Bazel Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Qualifiers are used to disambiguate or sub-select content that shares a URI.
/// This may include specifying a particular commit or branch, in the case of
/// URIs referencing a repository; they could also be used to specify a
/// particular subdirectory of a repository or tarball. Qualifiers may also be
/// used to ensure content matches what the client expects, even when there is
/// no ambiguity to be had - for example, a qualifier specifying a checksum
/// value.
///
/// In cases where the semantics of the request are not immediately clear from
/// the URL and/or qualifiers - e.g. dictated by URL scheme - it is recommended
/// to use an additional qualifier to remove the ambiguity. The `resource_type`
/// qualifier is recommended for this purpose.
///
/// Qualifiers may be supplied in any order.
public struct Build_Bazel_Remote_Asset_V1_Qualifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The "name" of the qualifier, for example "resource_type".
  /// No separation is made between 'standard' and 'nonstandard'
  /// qualifiers, in accordance with https://tools.ietf.org/html/rfc6648,
  /// however implementers *SHOULD* take care to avoid ambiguity.
  public var name: String = String()

  /// The "value" of the qualifier. Semantics will be dictated by the name.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [Fetch.FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
public struct Build_Bazel_Remote_Asset_V1_FetchBlobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The timeout for the underlying fetch, if content needs to be retrieved from
  /// origin.
  ///
  /// If unset, the server *MAY* apply an implementation-defined timeout.
  ///
  /// If set, and the user-provided timeout exceeds the RPC deadline, the server
  /// *SHOULD* keep the fetch going after the RPC completes, to be made
  /// available for future Fetch calls. The server may also enforce (via clamping
  /// and/or an INVALID_ARGUMENT error) implementation-defined minimum and
  /// maximum timeout values.
  ///
  /// If this timeout is exceeded on an attempt to retrieve content from origin
  /// the client will receive DEADLINE_EXCEEDED in [FetchBlobResponse.status].
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// The oldest content the client is willing to accept, as measured from the
  /// time it was Push'd or when the underlying retrieval from origin was 
  /// started.
  /// Upon retries of Fetch requests that cannot be completed within a single
  /// RPC, clients *SHOULD* provide the same value for subsequent requests as the
  /// original, to simplify combining the request with the previous attempt.
  ///
  /// If unset, the client *SHOULD* accept content of any age.
  public var oldestContentAccepted: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _oldestContentAccepted ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_oldestContentAccepted = newValue}
  }
  /// Returns true if `oldestContentAccepted` has been explicitly set.
  public var hasOldestContentAccepted: Bool {return self._oldestContentAccepted != nil}
  /// Clears the value of `oldestContentAccepted`. Subsequent reads from it will return its default value.
  public mutating func clearOldestContentAccepted() {self._oldestContentAccepted = nil}

  /// The URI(s) of the content to fetch. These may be resources that the server
  /// can directly fetch from origin, in which case multiple URIs *SHOULD*
  /// represent the same content available at different locations (such as an
  /// origin and secondary mirrors). These may also be URIs for content known to
  /// the server through other mechanisms, e.g. pushed via the [Push][build.bazel.remote.asset.v1.Push]
  /// service.
  ///
  /// Clients *MUST* supply at least one URI. Servers *MAY* match any one of the
  /// supplied URIs.
  public var uris: [String] = []

  /// Qualifiers sub-specifying the content to fetch - see comments on
  /// [Qualifier][build.bazel.remote.asset.v1.Qualifier].
  /// The same qualifiers apply to all URIs.
  ///
  /// Specified qualifier names *MUST* be unique.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _oldestContentAccepted: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A response message for
/// [Fetch.FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
public struct Build_Bazel_Remote_Asset_V1_FetchBlobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the status has a code other than `OK`, it indicates that the operation
  /// was unable to be completed for reasons outside the servers' control.
  /// The possible fetch errors include:
  /// * `DEADLINE_EXCEEDED`: The operation could not be completed within the
  ///   specified timeout.
  /// * `NOT_FOUND`: The requested asset was not found at the specified location.
  /// * `PERMISSION_DENIED`: The request was rejected by a remote server, or
  ///   requested an asset from a disallowed origin.
  /// * `ABORTED`: The operation could not be completed, typically due to a
  ///   failed consistency check.
  public var status: Google_Rpc_Status {
    get {return _status ?? Google_Rpc_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The uri from the request that resulted in a successful retrieval, or from
  /// which the error indicated in `status` was obtained.
  public var uri: String = String()

  /// Any qualifiers known to the server and of interest to clients.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  /// A minimum timestamp the content is expected to be available through.
  /// Servers *MAY* omit this field, if not known with confidence.
  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  /// The result of the fetch, if the status had code `OK`.
  /// The digest of the file's contents, available for download through the CAS.
  public var blobDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _blobDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_blobDigest = newValue}
  }
  /// Returns true if `blobDigest` has been explicitly set.
  public var hasBlobDigest: Bool {return self._blobDigest != nil}
  /// Clears the value of `blobDigest`. Subsequent reads from it will return its default value.
  public mutating func clearBlobDigest() {self._blobDigest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Google_Rpc_Status? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _blobDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A request message for
/// [Fetch.FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
public struct Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The timeout for the underlying fetch, if content needs to be retrieved from
  /// origin. This value is allowed to exceed the RPC deadline, in which case the
  /// server *SHOULD* keep the fetch going after the RPC completes, to be made
  /// available for future Fetch calls.
  ///
  /// If this timeout is exceeded on an attempt to retrieve content from origin
  /// the client will receive DEADLINE_EXCEEDED in [FetchDirectoryResponse.status].
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// The oldest content the client is willing to accept, as measured from the
  /// time it was Push'd or when the underlying retrieval from origin was
  /// started.
  /// Upon retries of Fetch requests that cannot be completed within a single
  /// RPC, clients *SHOULD* provide the same value for subsequent requests as the
  /// original, to simplify combining the request with the previous attempt.
  ///
  /// If unset, the client *SHOULD* accept content of any age.
  public var oldestContentAccepted: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _oldestContentAccepted ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_oldestContentAccepted = newValue}
  }
  /// Returns true if `oldestContentAccepted` has been explicitly set.
  public var hasOldestContentAccepted: Bool {return self._oldestContentAccepted != nil}
  /// Clears the value of `oldestContentAccepted`. Subsequent reads from it will return its default value.
  public mutating func clearOldestContentAccepted() {self._oldestContentAccepted = nil}

  /// The URI(s) of the content to fetch. These may be resources that the server
  /// can directly fetch from origin, in which case multiple URIs *SHOULD*
  /// represent the same content available at different locations (such as an
  /// origin and secondary mirrors). These may also be URIs for content known to
  /// the server through other mechanisms, e.g. pushed via the [Push][build.bazel.remote.asset.v1.Push]
  /// service.
  ///
  /// Clients *MUST* supply at least one URI. Servers *MAY* match any one of the
  /// supplied URIs.
  public var uris: [String] = []

  /// Qualifiers sub-specifying the content to fetch - see comments on
  /// [Qualifier][build.bazel.remote.asset.v1.Qualifier].
  /// The same qualifiers apply to all URIs.
  ///
  /// Specified qualifier names *MUST* be unique.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _oldestContentAccepted: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A response message for
/// [Fetch.FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
public struct Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the status has a code other than `OK`, it indicates that the operation
  /// was unable to be completed for reasons outside the servers' control.
  /// The possible fetch errors include:
  /// * `DEADLINE_EXCEEDED`: The operation could not be completed within the
  ///   specified timeout.
  /// * `NOT_FOUND`: The requested asset was not found at the specified location.
  /// * `PERMISSION_DENIED`: The request was rejected by a remote server, or
  ///   requested an asset from a disallowed origin.
  /// * `ABORTED`: The operation could not be completed, typically due to a
  ///   failed consistency check.
  public var status: Google_Rpc_Status {
    get {return _status ?? Google_Rpc_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The uri from the request that resulted in a successful retrieval, or from
  /// which the error indicated in `status` was obtained.
  public var uri: String = String()

  /// Any qualifiers known to the server and of interest to clients.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  /// A minimum timestamp the content is expected to be available through.
  /// Servers *MAY* omit this field, if not known with confidence.
  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  /// The result of the fetch, if the status had code `OK`.
  /// the root digest of a directory tree, suitable for fetching via
  /// [ContentAddressableStorage.GetTree].
  public var rootDirectoryDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _rootDirectoryDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_rootDirectoryDigest = newValue}
  }
  /// Returns true if `rootDirectoryDigest` has been explicitly set.
  public var hasRootDirectoryDigest: Bool {return self._rootDirectoryDigest != nil}
  /// Clears the value of `rootDirectoryDigest`. Subsequent reads from it will return its default value.
  public mutating func clearRootDirectoryDigest() {self._rootDirectoryDigest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Google_Rpc_Status? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _rootDirectoryDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A request message for
/// [Push.PushBlob][build.bazel.remote.asset.v1.Push.PushBlob].
public struct Build_Bazel_Remote_Asset_V1_PushBlobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The URI(s) of the content to associate. If multiple URIs are specified, the
  /// pushed content will be available to fetch by specifying any of them.
  public var uris: [String] = []

  /// Qualifiers sub-specifying the content that is being pushed - see comments
  /// on [Qualifier][build.bazel.remote.asset.v1.Qualifier].
  /// The same qualifiers apply to all URIs.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  /// A time after which this content should stop being returned via [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
  /// Servers *MAY* expire content early, e.g. due to storage pressure.
  public var expireAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireAt = newValue}
  }
  /// Returns true if `expireAt` has been explicitly set.
  public var hasExpireAt: Bool {return self._expireAt != nil}
  /// Clears the value of `expireAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpireAt() {self._expireAt = nil}

  /// The blob to associate.
  public var blobDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _blobDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_blobDigest = newValue}
  }
  /// Returns true if `blobDigest` has been explicitly set.
  public var hasBlobDigest: Bool {return self._blobDigest != nil}
  /// Clears the value of `blobDigest`. Subsequent reads from it will return its default value.
  public mutating func clearBlobDigest() {self._blobDigest = nil}

  /// Referenced blobs or directories that need to not expire before expiration
  /// of this association, in addition to `blob_digest` itself.
  /// These fields are hints - clients *MAY* omit them, and servers *SHOULD*
  /// respect them, at the risk of increased incidents of Fetch responses
  /// indirectly referencing unavailable blobs.
  public var referencesBlobs: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var referencesDirectories: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _blobDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A response message for
/// [Push.PushBlob][build.bazel.remote.asset.v1.Push.PushBlob].
public struct Build_Bazel_Remote_Asset_V1_PushBlobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for
/// [Push.PushDirectory][build.bazel.remote.asset.v1.Push.PushDirectory].
public struct Build_Bazel_Remote_Asset_V1_PushDirectoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance of the execution system to operate against. A server may
  /// support multiple instances of the execution system (with their own workers,
  /// storage, caches, etc.). The server MAY require use of this field to select
  /// between them in an implementation-defined fashion, otherwise it can be
  /// omitted.
  public var instanceName: String = String()

  /// The URI(s) of the content to associate. If multiple URIs are specified, the
  /// pushed content will be available to fetch by specifying any of them.
  public var uris: [String] = []

  /// Qualifiers sub-specifying the content that is being pushed - see comments
  /// on [Qualifier][build.bazel.remote.asset.v1.Qualifier].
  /// The same qualifiers apply to all URIs.
  public var qualifiers: [Build_Bazel_Remote_Asset_V1_Qualifier] = []

  /// A time after which this content should stop being returned via
  /// [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
  /// Servers *MAY* expire content early, e.g. due to storage pressure.
  public var expireAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireAt = newValue}
  }
  /// Returns true if `expireAt` has been explicitly set.
  public var hasExpireAt: Bool {return self._expireAt != nil}
  /// Clears the value of `expireAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpireAt() {self._expireAt = nil}

  /// Directory to associate
  public var rootDirectoryDigest: Build_Bazel_Remote_Execution_V2_Digest {
    get {return _rootDirectoryDigest ?? Build_Bazel_Remote_Execution_V2_Digest()}
    set {_rootDirectoryDigest = newValue}
  }
  /// Returns true if `rootDirectoryDigest` has been explicitly set.
  public var hasRootDirectoryDigest: Bool {return self._rootDirectoryDigest != nil}
  /// Clears the value of `rootDirectoryDigest`. Subsequent reads from it will return its default value.
  public mutating func clearRootDirectoryDigest() {self._rootDirectoryDigest = nil}

  /// Referenced blobs or directories that need to not expire before expiration
  /// of this association, in addition to `root_directory_digest` itself.
  /// These fields are hints - clients *MAY* omit them, and servers *SHOULD*
  /// respect them, at the risk of increased incidents of Fetch responses
  /// indirectly referencing unavailable blobs.
  public var referencesBlobs: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var referencesDirectories: [Build_Bazel_Remote_Execution_V2_Digest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _rootDirectoryDigest: Build_Bazel_Remote_Execution_V2_Digest? = nil
}

/// A response message for
/// [Push.PushDirectory][build.bazel.remote.asset.v1.Push.PushDirectory].
public struct Build_Bazel_Remote_Asset_V1_PushDirectoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build.bazel.remote.asset.v1"

extension Build_Bazel_Remote_Asset_V1_Qualifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Qualifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_Qualifier, rhs: Build_Bazel_Remote_Asset_V1_Qualifier) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_FetchBlobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchBlobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "timeout"),
    3: .standard(proto: "oldest_content_accepted"),
    4: .same(proto: "uris"),
    5: .same(proto: "qualifiers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instanceName)
      case 2: try decoder.decodeSingularMessageField(value: &self._timeout)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldestContentAccepted)
      case 4: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldestContentAccepted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 4)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_FetchBlobRequest, rhs: Build_Bazel_Remote_Asset_V1_FetchBlobRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._oldestContentAccepted != rhs._oldestContentAccepted {return false}
    if lhs.uris != rhs.uris {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_FetchBlobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchBlobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "uri"),
    3: .same(proto: "qualifiers"),
    4: .standard(proto: "expires_at"),
    5: .standard(proto: "blob_digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._status)
      case 2: try decoder.decodeSingularStringField(value: &self.uri)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      case 4: try decoder.decodeSingularMessageField(value: &self._expiresAt)
      case 5: try decoder.decodeSingularMessageField(value: &self._blobDigest)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 3)
    }
    if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._blobDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_FetchBlobResponse, rhs: Build_Bazel_Remote_Asset_V1_FetchBlobResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs._blobDigest != rhs._blobDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchDirectoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "timeout"),
    3: .standard(proto: "oldest_content_accepted"),
    4: .same(proto: "uris"),
    5: .same(proto: "qualifiers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instanceName)
      case 2: try decoder.decodeSingularMessageField(value: &self._timeout)
      case 3: try decoder.decodeSingularMessageField(value: &self._oldestContentAccepted)
      case 4: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._oldestContentAccepted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 4)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest, rhs: Build_Bazel_Remote_Asset_V1_FetchDirectoryRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._oldestContentAccepted != rhs._oldestContentAccepted {return false}
    if lhs.uris != rhs.uris {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchDirectoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "uri"),
    3: .same(proto: "qualifiers"),
    4: .standard(proto: "expires_at"),
    5: .standard(proto: "root_directory_digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._status)
      case 2: try decoder.decodeSingularStringField(value: &self.uri)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      case 4: try decoder.decodeSingularMessageField(value: &self._expiresAt)
      case 5: try decoder.decodeSingularMessageField(value: &self._rootDirectoryDigest)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 3)
    }
    if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._rootDirectoryDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse, rhs: Build_Bazel_Remote_Asset_V1_FetchDirectoryResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs._rootDirectoryDigest != rhs._rootDirectoryDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_PushBlobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushBlobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "uris"),
    3: .same(proto: "qualifiers"),
    4: .standard(proto: "expire_at"),
    5: .standard(proto: "blob_digest"),
    6: .standard(proto: "references_blobs"),
    7: .standard(proto: "references_directories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instanceName)
      case 2: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      case 4: try decoder.decodeSingularMessageField(value: &self._expireAt)
      case 5: try decoder.decodeSingularMessageField(value: &self._blobDigest)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.referencesBlobs)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.referencesDirectories)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 2)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 3)
    }
    if let v = self._expireAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._blobDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.referencesBlobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referencesBlobs, fieldNumber: 6)
    }
    if !self.referencesDirectories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referencesDirectories, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_PushBlobRequest, rhs: Build_Bazel_Remote_Asset_V1_PushBlobRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.uris != rhs.uris {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs._expireAt != rhs._expireAt {return false}
    if lhs._blobDigest != rhs._blobDigest {return false}
    if lhs.referencesBlobs != rhs.referencesBlobs {return false}
    if lhs.referencesDirectories != rhs.referencesDirectories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_PushBlobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushBlobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_PushBlobResponse, rhs: Build_Bazel_Remote_Asset_V1_PushBlobResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_PushDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushDirectoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .same(proto: "uris"),
    3: .same(proto: "qualifiers"),
    4: .standard(proto: "expire_at"),
    5: .standard(proto: "root_directory_digest"),
    6: .standard(proto: "references_blobs"),
    7: .standard(proto: "references_directories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.instanceName)
      case 2: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.qualifiers)
      case 4: try decoder.decodeSingularMessageField(value: &self._expireAt)
      case 5: try decoder.decodeSingularMessageField(value: &self._rootDirectoryDigest)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.referencesBlobs)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.referencesDirectories)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 2)
    }
    if !self.qualifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qualifiers, fieldNumber: 3)
    }
    if let v = self._expireAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._rootDirectoryDigest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.referencesBlobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referencesBlobs, fieldNumber: 6)
    }
    if !self.referencesDirectories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referencesDirectories, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_PushDirectoryRequest, rhs: Build_Bazel_Remote_Asset_V1_PushDirectoryRequest) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.uris != rhs.uris {return false}
    if lhs.qualifiers != rhs.qualifiers {return false}
    if lhs._expireAt != rhs._expireAt {return false}
    if lhs._rootDirectoryDigest != rhs._rootDirectoryDigest {return false}
    if lhs.referencesBlobs != rhs.referencesBlobs {return false}
    if lhs.referencesDirectories != rhs.referencesDirectories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Build_Bazel_Remote_Asset_V1_PushDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushDirectoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Build_Bazel_Remote_Asset_V1_PushDirectoryResponse, rhs: Build_Bazel_Remote_Asset_V1_PushDirectoryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
